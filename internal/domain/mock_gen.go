// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
	"context"
	"time"

	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockAssistant creates a new instance of MockAssistant. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAssistant(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAssistant {
	mock := &MockAssistant{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAssistant is an autogenerated mock type for the Assistant type
type MockAssistant struct {
	mock.Mock
}

type MockAssistant_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAssistant) EXPECT() *MockAssistant_Expecter {
	return &MockAssistant_Expecter{mock: &_m.Mock}
}

// RunTurn provides a mock function for the type MockAssistant
func (_mock *MockAssistant) RunTurn(ctx context.Context, req AssistantTurnRequest, onEvent AssistantEventCallback) error {
	ret := _mock.Called(ctx, req, onEvent)

	if len(ret) == 0 {
		panic("no return value specified for RunTurn")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, AssistantTurnRequest, AssistantEventCallback) error); ok {
		r0 = returnFunc(ctx, req, onEvent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockAssistant_RunTurn_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunTurn'
type MockAssistant_RunTurn_Call struct {
	*mock.Call
}

// RunTurn is a helper method to define mock.On call
//   - ctx context.Context
//   - req AssistantTurnRequest
//   - onEvent AssistantEventCallback
func (_e *MockAssistant_Expecter) RunTurn(ctx interface{}, req interface{}, onEvent interface{}) *MockAssistant_RunTurn_Call {
	return &MockAssistant_RunTurn_Call{Call: _e.mock.On("RunTurn", ctx, req, onEvent)}
}

func (_c *MockAssistant_RunTurn_Call) Run(run func(ctx context.Context, req AssistantTurnRequest, onEvent AssistantEventCallback)) *MockAssistant_RunTurn_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 AssistantTurnRequest
		if args[1] != nil {
			arg1 = args[1].(AssistantTurnRequest)
		}
		var arg2 AssistantEventCallback
		if args[2] != nil {
			arg2 = args[2].(AssistantEventCallback)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAssistant_RunTurn_Call) Return(err error) *MockAssistant_RunTurn_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockAssistant_RunTurn_Call) RunAndReturn(run func(ctx context.Context, req AssistantTurnRequest, onEvent AssistantEventCallback) error) *MockAssistant_RunTurn_Call {
	_c.Call.Return(run)
	return _c
}

// RunTurnSync provides a mock function for the type MockAssistant
func (_mock *MockAssistant) RunTurnSync(ctx context.Context, req AssistantTurnRequest) (AssistantTurnResponse, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for RunTurnSync")
	}

	var r0 AssistantTurnResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, AssistantTurnRequest) (AssistantTurnResponse, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, AssistantTurnRequest) AssistantTurnResponse); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Get(0).(AssistantTurnResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, AssistantTurnRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAssistant_RunTurnSync_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RunTurnSync'
type MockAssistant_RunTurnSync_Call struct {
	*mock.Call
}

// RunTurnSync is a helper method to define mock.On call
//   - ctx context.Context
//   - req AssistantTurnRequest
func (_e *MockAssistant_Expecter) RunTurnSync(ctx interface{}, req interface{}) *MockAssistant_RunTurnSync_Call {
	return &MockAssistant_RunTurnSync_Call{Call: _e.mock.On("RunTurnSync", ctx, req)}
}

func (_c *MockAssistant_RunTurnSync_Call) Run(run func(ctx context.Context, req AssistantTurnRequest)) *MockAssistant_RunTurnSync_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 AssistantTurnRequest
		if args[1] != nil {
			arg1 = args[1].(AssistantTurnRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAssistant_RunTurnSync_Call) Return(assistantTurnResponse AssistantTurnResponse, err error) *MockAssistant_RunTurnSync_Call {
	_c.Call.Return(assistantTurnResponse, err)
	return _c
}

func (_c *MockAssistant_RunTurnSync_Call) RunAndReturn(run func(ctx context.Context, req AssistantTurnRequest) (AssistantTurnResponse, error)) *MockAssistant_RunTurnSync_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAssistantAction creates a new instance of MockAssistantAction. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAssistantAction(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAssistantAction {
	mock := &MockAssistantAction{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAssistantAction is an autogenerated mock type for the AssistantAction type
type MockAssistantAction struct {
	mock.Mock
}

type MockAssistantAction_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAssistantAction) EXPECT() *MockAssistantAction_Expecter {
	return &MockAssistantAction_Expecter{mock: &_m.Mock}
}

// Definition provides a mock function for the type MockAssistantAction
func (_mock *MockAssistantAction) Definition() AssistantActionDefinition {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Definition")
	}

	var r0 AssistantActionDefinition
	if returnFunc, ok := ret.Get(0).(func() AssistantActionDefinition); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(AssistantActionDefinition)
	}
	return r0
}

// MockAssistantAction_Definition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Definition'
type MockAssistantAction_Definition_Call struct {
	*mock.Call
}

// Definition is a helper method to define mock.On call
func (_e *MockAssistantAction_Expecter) Definition() *MockAssistantAction_Definition_Call {
	return &MockAssistantAction_Definition_Call{Call: _e.mock.On("Definition")}
}

func (_c *MockAssistantAction_Definition_Call) Run(run func()) *MockAssistantAction_Definition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAssistantAction_Definition_Call) Return(assistantActionDefinition AssistantActionDefinition) *MockAssistantAction_Definition_Call {
	_c.Call.Return(assistantActionDefinition)
	return _c
}

func (_c *MockAssistantAction_Definition_Call) RunAndReturn(run func() AssistantActionDefinition) *MockAssistantAction_Definition_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function for the type MockAssistantAction
func (_mock *MockAssistantAction) Execute(context1 context.Context, assistantActionCall AssistantActionCall, assistantMessages []AssistantMessage) AssistantMessage {
	ret := _mock.Called(context1, assistantActionCall, assistantMessages)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 AssistantMessage
	if returnFunc, ok := ret.Get(0).(func(context.Context, AssistantActionCall, []AssistantMessage) AssistantMessage); ok {
		r0 = returnFunc(context1, assistantActionCall, assistantMessages)
	} else {
		r0 = ret.Get(0).(AssistantMessage)
	}
	return r0
}

// MockAssistantAction_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockAssistantAction_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - context1 context.Context
//   - assistantActionCall AssistantActionCall
//   - assistantMessages []AssistantMessage
func (_e *MockAssistantAction_Expecter) Execute(context1 interface{}, assistantActionCall interface{}, assistantMessages interface{}) *MockAssistantAction_Execute_Call {
	return &MockAssistantAction_Execute_Call{Call: _e.mock.On("Execute", context1, assistantActionCall, assistantMessages)}
}

func (_c *MockAssistantAction_Execute_Call) Run(run func(context1 context.Context, assistantActionCall AssistantActionCall, assistantMessages []AssistantMessage)) *MockAssistantAction_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 AssistantActionCall
		if args[1] != nil {
			arg1 = args[1].(AssistantActionCall)
		}
		var arg2 []AssistantMessage
		if args[2] != nil {
			arg2 = args[2].([]AssistantMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAssistantAction_Execute_Call) Return(assistantMessage AssistantMessage) *MockAssistantAction_Execute_Call {
	_c.Call.Return(assistantMessage)
	return _c
}

func (_c *MockAssistantAction_Execute_Call) RunAndReturn(run func(context1 context.Context, assistantActionCall AssistantActionCall, assistantMessages []AssistantMessage) AssistantMessage) *MockAssistantAction_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// StatusMessage provides a mock function for the type MockAssistantAction
func (_mock *MockAssistantAction) StatusMessage() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for StatusMessage")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockAssistantAction_StatusMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusMessage'
type MockAssistantAction_StatusMessage_Call struct {
	*mock.Call
}

// StatusMessage is a helper method to define mock.On call
func (_e *MockAssistantAction_Expecter) StatusMessage() *MockAssistantAction_StatusMessage_Call {
	return &MockAssistantAction_StatusMessage_Call{Call: _e.mock.On("StatusMessage")}
}

func (_c *MockAssistantAction_StatusMessage_Call) Run(run func()) *MockAssistantAction_StatusMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAssistantAction_StatusMessage_Call) Return(s string) *MockAssistantAction_StatusMessage_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockAssistantAction_StatusMessage_Call) RunAndReturn(run func() string) *MockAssistantAction_StatusMessage_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAssistantActionRegistry creates a new instance of MockAssistantActionRegistry. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAssistantActionRegistry(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAssistantActionRegistry {
	mock := &MockAssistantActionRegistry{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAssistantActionRegistry is an autogenerated mock type for the AssistantActionRegistry type
type MockAssistantActionRegistry struct {
	mock.Mock
}

type MockAssistantActionRegistry_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAssistantActionRegistry) EXPECT() *MockAssistantActionRegistry_Expecter {
	return &MockAssistantActionRegistry_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockAssistantActionRegistry
func (_mock *MockAssistantActionRegistry) Execute(context1 context.Context, assistantActionCall AssistantActionCall, assistantMessages []AssistantMessage) AssistantMessage {
	ret := _mock.Called(context1, assistantActionCall, assistantMessages)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 AssistantMessage
	if returnFunc, ok := ret.Get(0).(func(context.Context, AssistantActionCall, []AssistantMessage) AssistantMessage); ok {
		r0 = returnFunc(context1, assistantActionCall, assistantMessages)
	} else {
		r0 = ret.Get(0).(AssistantMessage)
	}
	return r0
}

// MockAssistantActionRegistry_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockAssistantActionRegistry_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - context1 context.Context
//   - assistantActionCall AssistantActionCall
//   - assistantMessages []AssistantMessage
func (_e *MockAssistantActionRegistry_Expecter) Execute(context1 interface{}, assistantActionCall interface{}, assistantMessages interface{}) *MockAssistantActionRegistry_Execute_Call {
	return &MockAssistantActionRegistry_Execute_Call{Call: _e.mock.On("Execute", context1, assistantActionCall, assistantMessages)}
}

func (_c *MockAssistantActionRegistry_Execute_Call) Run(run func(context1 context.Context, assistantActionCall AssistantActionCall, assistantMessages []AssistantMessage)) *MockAssistantActionRegistry_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 AssistantActionCall
		if args[1] != nil {
			arg1 = args[1].(AssistantActionCall)
		}
		var arg2 []AssistantMessage
		if args[2] != nil {
			arg2 = args[2].([]AssistantMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockAssistantActionRegistry_Execute_Call) Return(assistantMessage AssistantMessage) *MockAssistantActionRegistry_Execute_Call {
	_c.Call.Return(assistantMessage)
	return _c
}

func (_c *MockAssistantActionRegistry_Execute_Call) RunAndReturn(run func(context1 context.Context, assistantActionCall AssistantActionCall, assistantMessages []AssistantMessage) AssistantMessage) *MockAssistantActionRegistry_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockAssistantActionRegistry
func (_mock *MockAssistantActionRegistry) List() []AssistantActionDefinition {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []AssistantActionDefinition
	if returnFunc, ok := ret.Get(0).(func() []AssistantActionDefinition); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]AssistantActionDefinition)
		}
	}
	return r0
}

// MockAssistantActionRegistry_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockAssistantActionRegistry_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
func (_e *MockAssistantActionRegistry_Expecter) List() *MockAssistantActionRegistry_List_Call {
	return &MockAssistantActionRegistry_List_Call{Call: _e.mock.On("List")}
}

func (_c *MockAssistantActionRegistry_List_Call) Run(run func()) *MockAssistantActionRegistry_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockAssistantActionRegistry_List_Call) Return(assistantActionDefinitions []AssistantActionDefinition) *MockAssistantActionRegistry_List_Call {
	_c.Call.Return(assistantActionDefinitions)
	return _c
}

func (_c *MockAssistantActionRegistry_List_Call) RunAndReturn(run func() []AssistantActionDefinition) *MockAssistantActionRegistry_List_Call {
	_c.Call.Return(run)
	return _c
}

// ListRelevant provides a mock function for the type MockAssistantActionRegistry
func (_mock *MockAssistantActionRegistry) ListRelevant(ctx context.Context, userInput string) []AssistantActionDefinition {
	ret := _mock.Called(ctx, userInput)

	if len(ret) == 0 {
		panic("no return value specified for ListRelevant")
	}

	var r0 []AssistantActionDefinition
	if returnFunc, ok := ret.Get(0).(func(context.Context, string) []AssistantActionDefinition); ok {
		r0 = returnFunc(ctx, userInput)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]AssistantActionDefinition)
		}
	}
	return r0
}

// MockAssistantActionRegistry_ListRelevant_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListRelevant'
type MockAssistantActionRegistry_ListRelevant_Call struct {
	*mock.Call
}

// ListRelevant is a helper method to define mock.On call
//   - ctx context.Context
//   - userInput string
func (_e *MockAssistantActionRegistry_Expecter) ListRelevant(ctx interface{}, userInput interface{}) *MockAssistantActionRegistry_ListRelevant_Call {
	return &MockAssistantActionRegistry_ListRelevant_Call{Call: _e.mock.On("ListRelevant", ctx, userInput)}
}

func (_c *MockAssistantActionRegistry_ListRelevant_Call) Run(run func(ctx context.Context, userInput string)) *MockAssistantActionRegistry_ListRelevant_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockAssistantActionRegistry_ListRelevant_Call) Return(assistantActionDefinitions []AssistantActionDefinition) *MockAssistantActionRegistry_ListRelevant_Call {
	_c.Call.Return(assistantActionDefinitions)
	return _c
}

func (_c *MockAssistantActionRegistry_ListRelevant_Call) RunAndReturn(run func(ctx context.Context, userInput string) []AssistantActionDefinition) *MockAssistantActionRegistry_ListRelevant_Call {
	_c.Call.Return(run)
	return _c
}

// StatusMessage provides a mock function for the type MockAssistantActionRegistry
func (_mock *MockAssistantActionRegistry) StatusMessage(actionName string) string {
	ret := _mock.Called(actionName)

	if len(ret) == 0 {
		panic("no return value specified for StatusMessage")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(actionName)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockAssistantActionRegistry_StatusMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusMessage'
type MockAssistantActionRegistry_StatusMessage_Call struct {
	*mock.Call
}

// StatusMessage is a helper method to define mock.On call
//   - actionName string
func (_e *MockAssistantActionRegistry_Expecter) StatusMessage(actionName interface{}) *MockAssistantActionRegistry_StatusMessage_Call {
	return &MockAssistantActionRegistry_StatusMessage_Call{Call: _e.mock.On("StatusMessage", actionName)}
}

func (_c *MockAssistantActionRegistry_StatusMessage_Call) Run(run func(actionName string)) *MockAssistantActionRegistry_StatusMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAssistantActionRegistry_StatusMessage_Call) Return(s string) *MockAssistantActionRegistry_StatusMessage_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockAssistantActionRegistry_StatusMessage_Call) RunAndReturn(run func(actionName string) string) *MockAssistantActionRegistry_StatusMessage_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockAssistantModelCatalog creates a new instance of MockAssistantModelCatalog. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockAssistantModelCatalog(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockAssistantModelCatalog {
	mock := &MockAssistantModelCatalog{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockAssistantModelCatalog is an autogenerated mock type for the AssistantModelCatalog type
type MockAssistantModelCatalog struct {
	mock.Mock
}

type MockAssistantModelCatalog_Expecter struct {
	mock *mock.Mock
}

func (_m *MockAssistantModelCatalog) EXPECT() *MockAssistantModelCatalog_Expecter {
	return &MockAssistantModelCatalog_Expecter{mock: &_m.Mock}
}

// ListAssistantModels provides a mock function for the type MockAssistantModelCatalog
func (_mock *MockAssistantModelCatalog) ListAssistantModels(ctx context.Context) ([]AssistantModelInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListAssistantModels")
	}

	var r0 []AssistantModelInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]AssistantModelInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []AssistantModelInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]AssistantModelInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockAssistantModelCatalog_ListAssistantModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListAssistantModels'
type MockAssistantModelCatalog_ListAssistantModels_Call struct {
	*mock.Call
}

// ListAssistantModels is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockAssistantModelCatalog_Expecter) ListAssistantModels(ctx interface{}) *MockAssistantModelCatalog_ListAssistantModels_Call {
	return &MockAssistantModelCatalog_ListAssistantModels_Call{Call: _e.mock.On("ListAssistantModels", ctx)}
}

func (_c *MockAssistantModelCatalog_ListAssistantModels_Call) Run(run func(ctx context.Context)) *MockAssistantModelCatalog_ListAssistantModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockAssistantModelCatalog_ListAssistantModels_Call) Return(assistantModelInfos []AssistantModelInfo, err error) *MockAssistantModelCatalog_ListAssistantModels_Call {
	_c.Call.Return(assistantModelInfos, err)
	return _c
}

func (_c *MockAssistantModelCatalog_ListAssistantModels_Call) RunAndReturn(run func(ctx context.Context) ([]AssistantModelInfo, error)) *MockAssistantModelCatalog_ListAssistantModels_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockChatMessageRepository creates a new instance of MockChatMessageRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChatMessageRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockChatMessageRepository {
	mock := &MockChatMessageRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockChatMessageRepository is an autogenerated mock type for the ChatMessageRepository type
type MockChatMessageRepository struct {
	mock.Mock
}

type MockChatMessageRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockChatMessageRepository) EXPECT() *MockChatMessageRepository_Expecter {
	return &MockChatMessageRepository_Expecter{mock: &_m.Mock}
}

// CreateChatMessages provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) CreateChatMessages(ctx context.Context, messages []ChatMessage) error {
	ret := _mock.Called(ctx, messages)

	if len(ret) == 0 {
		panic("no return value specified for CreateChatMessages")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []ChatMessage) error); ok {
		r0 = returnFunc(ctx, messages)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatMessageRepository_CreateChatMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateChatMessages'
type MockChatMessageRepository_CreateChatMessages_Call struct {
	*mock.Call
}

// CreateChatMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - messages []ChatMessage
func (_e *MockChatMessageRepository_Expecter) CreateChatMessages(ctx interface{}, messages interface{}) *MockChatMessageRepository_CreateChatMessages_Call {
	return &MockChatMessageRepository_CreateChatMessages_Call{Call: _e.mock.On("CreateChatMessages", ctx, messages)}
}

func (_c *MockChatMessageRepository_CreateChatMessages_Call) Run(run func(ctx context.Context, messages []ChatMessage)) *MockChatMessageRepository_CreateChatMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []ChatMessage
		if args[1] != nil {
			arg1 = args[1].([]ChatMessage)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_CreateChatMessages_Call) Return(err error) *MockChatMessageRepository_CreateChatMessages_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatMessageRepository_CreateChatMessages_Call) RunAndReturn(run func(ctx context.Context, messages []ChatMessage) error) *MockChatMessageRepository_CreateChatMessages_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConversationMessages provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) DeleteConversationMessages(ctx context.Context, conversationID uuid.UUID) error {
	ret := _mock.Called(ctx, conversationID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConversationMessages")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, conversationID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatMessageRepository_DeleteConversationMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConversationMessages'
type MockChatMessageRepository_DeleteConversationMessages_Call struct {
	*mock.Call
}

// DeleteConversationMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - conversationID uuid.UUID
func (_e *MockChatMessageRepository_Expecter) DeleteConversationMessages(ctx interface{}, conversationID interface{}) *MockChatMessageRepository_DeleteConversationMessages_Call {
	return &MockChatMessageRepository_DeleteConversationMessages_Call{Call: _e.mock.On("DeleteConversationMessages", ctx, conversationID)}
}

func (_c *MockChatMessageRepository_DeleteConversationMessages_Call) Run(run func(ctx context.Context, conversationID uuid.UUID)) *MockChatMessageRepository_DeleteConversationMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_DeleteConversationMessages_Call) Return(err error) *MockChatMessageRepository_DeleteConversationMessages_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatMessageRepository_DeleteConversationMessages_Call) RunAndReturn(run func(ctx context.Context, conversationID uuid.UUID) error) *MockChatMessageRepository_DeleteConversationMessages_Call {
	_c.Call.Return(run)
	return _c
}

// ListChatMessages provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) ListChatMessages(ctx context.Context, conversationID uuid.UUID, page int, pageSize int, options ...ListChatMessagesOption) ([]ChatMessage, bool, error) {
	var tmpRet mock.Arguments
	if len(options) > 0 {
		tmpRet = _mock.Called(ctx, conversationID, page, pageSize, options)
	} else {
		tmpRet = _mock.Called(ctx, conversationID, page, pageSize)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListChatMessages")
	}

	var r0 []ChatMessage
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int, ...ListChatMessagesOption) ([]ChatMessage, bool, error)); ok {
		return returnFunc(ctx, conversationID, page, pageSize, options...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, int, int, ...ListChatMessagesOption) []ChatMessage); ok {
		r0 = returnFunc(ctx, conversationID, page, pageSize, options...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ChatMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID, int, int, ...ListChatMessagesOption) bool); ok {
		r1 = returnFunc(ctx, conversationID, page, pageSize, options...)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID, int, int, ...ListChatMessagesOption) error); ok {
		r2 = returnFunc(ctx, conversationID, page, pageSize, options...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockChatMessageRepository_ListChatMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChatMessages'
type MockChatMessageRepository_ListChatMessages_Call struct {
	*mock.Call
}

// ListChatMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - conversationID uuid.UUID
//   - page int
//   - pageSize int
//   - options ...ListChatMessagesOption
func (_e *MockChatMessageRepository_Expecter) ListChatMessages(ctx interface{}, conversationID interface{}, page interface{}, pageSize interface{}, options ...interface{}) *MockChatMessageRepository_ListChatMessages_Call {
	return &MockChatMessageRepository_ListChatMessages_Call{Call: _e.mock.On("ListChatMessages",
		append([]interface{}{ctx, conversationID, page, pageSize}, options...)...)}
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) Run(run func(ctx context.Context, conversationID uuid.UUID, page int, pageSize int, options ...ListChatMessagesOption)) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 []ListChatMessagesOption
		var variadicArgs []ListChatMessagesOption
		if len(args) > 4 {
			variadicArgs = args[4].([]ListChatMessagesOption)
		}
		arg4 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4...,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) Return(chatMessages []ChatMessage, b bool, err error) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Return(chatMessages, b, err)
	return _c
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) RunAndReturn(run func(ctx context.Context, conversationID uuid.UUID, page int, pageSize int, options ...ListChatMessagesOption) ([]ChatMessage, bool, error)) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockConversationRepository creates a new instance of MockConversationRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConversationRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConversationRepository {
	mock := &MockConversationRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConversationRepository is an autogenerated mock type for the ConversationRepository type
type MockConversationRepository struct {
	mock.Mock
}

type MockConversationRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConversationRepository) EXPECT() *MockConversationRepository_Expecter {
	return &MockConversationRepository_Expecter{mock: &_m.Mock}
}

// CreateConversation provides a mock function for the type MockConversationRepository
func (_mock *MockConversationRepository) CreateConversation(context1 context.Context, s string, conversationTitleSource ConversationTitleSource) (Conversation, error) {
	ret := _mock.Called(context1, s, conversationTitleSource)

	if len(ret) == 0 {
		panic("no return value specified for CreateConversation")
	}

	var r0 Conversation
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ConversationTitleSource) (Conversation, error)); ok {
		return returnFunc(context1, s, conversationTitleSource)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, ConversationTitleSource) Conversation); ok {
		r0 = returnFunc(context1, s, conversationTitleSource)
	} else {
		r0 = ret.Get(0).(Conversation)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, ConversationTitleSource) error); ok {
		r1 = returnFunc(context1, s, conversationTitleSource)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockConversationRepository_CreateConversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateConversation'
type MockConversationRepository_CreateConversation_Call struct {
	*mock.Call
}

// CreateConversation is a helper method to define mock.On call
//   - context1 context.Context
//   - s string
//   - conversationTitleSource ConversationTitleSource
func (_e *MockConversationRepository_Expecter) CreateConversation(context1 interface{}, s interface{}, conversationTitleSource interface{}) *MockConversationRepository_CreateConversation_Call {
	return &MockConversationRepository_CreateConversation_Call{Call: _e.mock.On("CreateConversation", context1, s, conversationTitleSource)}
}

func (_c *MockConversationRepository_CreateConversation_Call) Run(run func(context1 context.Context, s string, conversationTitleSource ConversationTitleSource)) *MockConversationRepository_CreateConversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 ConversationTitleSource
		if args[2] != nil {
			arg2 = args[2].(ConversationTitleSource)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockConversationRepository_CreateConversation_Call) Return(conversation Conversation, err error) *MockConversationRepository_CreateConversation_Call {
	_c.Call.Return(conversation, err)
	return _c
}

func (_c *MockConversationRepository_CreateConversation_Call) RunAndReturn(run func(context1 context.Context, s string, conversationTitleSource ConversationTitleSource) (Conversation, error)) *MockConversationRepository_CreateConversation_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConversation provides a mock function for the type MockConversationRepository
func (_mock *MockConversationRepository) DeleteConversation(context1 context.Context, uUID uuid.UUID) error {
	ret := _mock.Called(context1, uUID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConversation")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(context1, uUID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConversationRepository_DeleteConversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConversation'
type MockConversationRepository_DeleteConversation_Call struct {
	*mock.Call
}

// DeleteConversation is a helper method to define mock.On call
//   - context1 context.Context
//   - uUID uuid.UUID
func (_e *MockConversationRepository_Expecter) DeleteConversation(context1 interface{}, uUID interface{}) *MockConversationRepository_DeleteConversation_Call {
	return &MockConversationRepository_DeleteConversation_Call{Call: _e.mock.On("DeleteConversation", context1, uUID)}
}

func (_c *MockConversationRepository_DeleteConversation_Call) Run(run func(context1 context.Context, uUID uuid.UUID)) *MockConversationRepository_DeleteConversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConversationRepository_DeleteConversation_Call) Return(err error) *MockConversationRepository_DeleteConversation_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConversationRepository_DeleteConversation_Call) RunAndReturn(run func(context1 context.Context, uUID uuid.UUID) error) *MockConversationRepository_DeleteConversation_Call {
	_c.Call.Return(run)
	return _c
}

// GetConversation provides a mock function for the type MockConversationRepository
func (_mock *MockConversationRepository) GetConversation(context1 context.Context, uUID uuid.UUID) (Conversation, bool, error) {
	ret := _mock.Called(context1, uUID)

	if len(ret) == 0 {
		panic("no return value specified for GetConversation")
	}

	var r0 Conversation
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (Conversation, bool, error)); ok {
		return returnFunc(context1, uUID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) Conversation); ok {
		r0 = returnFunc(context1, uUID)
	} else {
		r0 = ret.Get(0).(Conversation)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) bool); ok {
		r1 = returnFunc(context1, uUID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok {
		r2 = returnFunc(context1, uUID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockConversationRepository_GetConversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConversation'
type MockConversationRepository_GetConversation_Call struct {
	*mock.Call
}

// GetConversation is a helper method to define mock.On call
//   - context1 context.Context
//   - uUID uuid.UUID
func (_e *MockConversationRepository_Expecter) GetConversation(context1 interface{}, uUID interface{}) *MockConversationRepository_GetConversation_Call {
	return &MockConversationRepository_GetConversation_Call{Call: _e.mock.On("GetConversation", context1, uUID)}
}

func (_c *MockConversationRepository_GetConversation_Call) Run(run func(context1 context.Context, uUID uuid.UUID)) *MockConversationRepository_GetConversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConversationRepository_GetConversation_Call) Return(conversation Conversation, b bool, err error) *MockConversationRepository_GetConversation_Call {
	_c.Call.Return(conversation, b, err)
	return _c
}

func (_c *MockConversationRepository_GetConversation_Call) RunAndReturn(run func(context1 context.Context, uUID uuid.UUID) (Conversation, bool, error)) *MockConversationRepository_GetConversation_Call {
	_c.Call.Return(run)
	return _c
}

// ListConversations provides a mock function for the type MockConversationRepository
func (_mock *MockConversationRepository) ListConversations(ctx context.Context, page int, pageSize int) ([]Conversation, bool, error) {
	ret := _mock.Called(ctx, page, pageSize)

	if len(ret) == 0 {
		panic("no return value specified for ListConversations")
	}

	var r0 []Conversation
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) ([]Conversation, bool, error)); ok {
		return returnFunc(ctx, page, pageSize)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int) []Conversation); ok {
		r0 = returnFunc(ctx, page, pageSize)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Conversation)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int) bool); ok {
		r1 = returnFunc(ctx, page, pageSize)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int) error); ok {
		r2 = returnFunc(ctx, page, pageSize)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockConversationRepository_ListConversations_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListConversations'
type MockConversationRepository_ListConversations_Call struct {
	*mock.Call
}

// ListConversations is a helper method to define mock.On call
//   - ctx context.Context
//   - page int
//   - pageSize int
func (_e *MockConversationRepository_Expecter) ListConversations(ctx interface{}, page interface{}, pageSize interface{}) *MockConversationRepository_ListConversations_Call {
	return &MockConversationRepository_ListConversations_Call{Call: _e.mock.On("ListConversations", ctx, page, pageSize)}
}

func (_c *MockConversationRepository_ListConversations_Call) Run(run func(ctx context.Context, page int, pageSize int)) *MockConversationRepository_ListConversations_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockConversationRepository_ListConversations_Call) Return(conversations []Conversation, b bool, err error) *MockConversationRepository_ListConversations_Call {
	_c.Call.Return(conversations, b, err)
	return _c
}

func (_c *MockConversationRepository_ListConversations_Call) RunAndReturn(run func(ctx context.Context, page int, pageSize int) ([]Conversation, bool, error)) *MockConversationRepository_ListConversations_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateConversation provides a mock function for the type MockConversationRepository
func (_mock *MockConversationRepository) UpdateConversation(context1 context.Context, conversation Conversation) error {
	ret := _mock.Called(context1, conversation)

	if len(ret) == 0 {
		panic("no return value specified for UpdateConversation")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Conversation) error); ok {
		r0 = returnFunc(context1, conversation)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConversationRepository_UpdateConversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateConversation'
type MockConversationRepository_UpdateConversation_Call struct {
	*mock.Call
}

// UpdateConversation is a helper method to define mock.On call
//   - context1 context.Context
//   - conversation Conversation
func (_e *MockConversationRepository_Expecter) UpdateConversation(context1 interface{}, conversation interface{}) *MockConversationRepository_UpdateConversation_Call {
	return &MockConversationRepository_UpdateConversation_Call{Call: _e.mock.On("UpdateConversation", context1, conversation)}
}

func (_c *MockConversationRepository_UpdateConversation_Call) Run(run func(context1 context.Context, conversation Conversation)) *MockConversationRepository_UpdateConversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Conversation
		if args[1] != nil {
			arg1 = args[1].(Conversation)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConversationRepository_UpdateConversation_Call) Return(err error) *MockConversationRepository_UpdateConversation_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConversationRepository_UpdateConversation_Call) RunAndReturn(run func(context1 context.Context, conversation Conversation) error) *MockConversationRepository_UpdateConversation_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockConversationSummaryRepository creates a new instance of MockConversationSummaryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockConversationSummaryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockConversationSummaryRepository {
	mock := &MockConversationSummaryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockConversationSummaryRepository is an autogenerated mock type for the ConversationSummaryRepository type
type MockConversationSummaryRepository struct {
	mock.Mock
}

type MockConversationSummaryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockConversationSummaryRepository) EXPECT() *MockConversationSummaryRepository_Expecter {
	return &MockConversationSummaryRepository_Expecter{mock: &_m.Mock}
}

// DeleteConversationSummary provides a mock function for the type MockConversationSummaryRepository
func (_mock *MockConversationSummaryRepository) DeleteConversationSummary(ctx context.Context, conversationID uuid.UUID) error {
	ret := _mock.Called(ctx, conversationID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConversationSummary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, conversationID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConversationSummaryRepository_DeleteConversationSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConversationSummary'
type MockConversationSummaryRepository_DeleteConversationSummary_Call struct {
	*mock.Call
}

// DeleteConversationSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - conversationID uuid.UUID
func (_e *MockConversationSummaryRepository_Expecter) DeleteConversationSummary(ctx interface{}, conversationID interface{}) *MockConversationSummaryRepository_DeleteConversationSummary_Call {
	return &MockConversationSummaryRepository_DeleteConversationSummary_Call{Call: _e.mock.On("DeleteConversationSummary", ctx, conversationID)}
}

func (_c *MockConversationSummaryRepository_DeleteConversationSummary_Call) Run(run func(ctx context.Context, conversationID uuid.UUID)) *MockConversationSummaryRepository_DeleteConversationSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConversationSummaryRepository_DeleteConversationSummary_Call) Return(err error) *MockConversationSummaryRepository_DeleteConversationSummary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConversationSummaryRepository_DeleteConversationSummary_Call) RunAndReturn(run func(ctx context.Context, conversationID uuid.UUID) error) *MockConversationSummaryRepository_DeleteConversationSummary_Call {
	_c.Call.Return(run)
	return _c
}

// GetConversationSummary provides a mock function for the type MockConversationSummaryRepository
func (_mock *MockConversationSummaryRepository) GetConversationSummary(ctx context.Context, conversationID uuid.UUID) (ConversationSummary, bool, error) {
	ret := _mock.Called(ctx, conversationID)

	if len(ret) == 0 {
		panic("no return value specified for GetConversationSummary")
	}

	var r0 ConversationSummary
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (ConversationSummary, bool, error)); ok {
		return returnFunc(ctx, conversationID)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) ConversationSummary); ok {
		r0 = returnFunc(ctx, conversationID)
	} else {
		r0 = ret.Get(0).(ConversationSummary)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) bool); ok {
		r1 = returnFunc(ctx, conversationID)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok {
		r2 = returnFunc(ctx, conversationID)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockConversationSummaryRepository_GetConversationSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetConversationSummary'
type MockConversationSummaryRepository_GetConversationSummary_Call struct {
	*mock.Call
}

// GetConversationSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - conversationID uuid.UUID
func (_e *MockConversationSummaryRepository_Expecter) GetConversationSummary(ctx interface{}, conversationID interface{}) *MockConversationSummaryRepository_GetConversationSummary_Call {
	return &MockConversationSummaryRepository_GetConversationSummary_Call{Call: _e.mock.On("GetConversationSummary", ctx, conversationID)}
}

func (_c *MockConversationSummaryRepository_GetConversationSummary_Call) Run(run func(ctx context.Context, conversationID uuid.UUID)) *MockConversationSummaryRepository_GetConversationSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConversationSummaryRepository_GetConversationSummary_Call) Return(conversationSummary ConversationSummary, b bool, err error) *MockConversationSummaryRepository_GetConversationSummary_Call {
	_c.Call.Return(conversationSummary, b, err)
	return _c
}

func (_c *MockConversationSummaryRepository_GetConversationSummary_Call) RunAndReturn(run func(ctx context.Context, conversationID uuid.UUID) (ConversationSummary, bool, error)) *MockConversationSummaryRepository_GetConversationSummary_Call {
	_c.Call.Return(run)
	return _c
}

// StoreConversationSummary provides a mock function for the type MockConversationSummaryRepository
func (_mock *MockConversationSummaryRepository) StoreConversationSummary(ctx context.Context, summary ConversationSummary) error {
	ret := _mock.Called(ctx, summary)

	if len(ret) == 0 {
		panic("no return value specified for StoreConversationSummary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ConversationSummary) error); ok {
		r0 = returnFunc(ctx, summary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockConversationSummaryRepository_StoreConversationSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreConversationSummary'
type MockConversationSummaryRepository_StoreConversationSummary_Call struct {
	*mock.Call
}

// StoreConversationSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - summary ConversationSummary
func (_e *MockConversationSummaryRepository_Expecter) StoreConversationSummary(ctx interface{}, summary interface{}) *MockConversationSummaryRepository_StoreConversationSummary_Call {
	return &MockConversationSummaryRepository_StoreConversationSummary_Call{Call: _e.mock.On("StoreConversationSummary", ctx, summary)}
}

func (_c *MockConversationSummaryRepository_StoreConversationSummary_Call) Run(run func(ctx context.Context, summary ConversationSummary)) *MockConversationSummaryRepository_StoreConversationSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 ConversationSummary
		if args[1] != nil {
			arg1 = args[1].(ConversationSummary)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockConversationSummaryRepository_StoreConversationSummary_Call) Return(err error) *MockConversationSummaryRepository_StoreConversationSummary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockConversationSummaryRepository_StoreConversationSummary_Call) RunAndReturn(run func(ctx context.Context, summary ConversationSummary) error) *MockConversationSummaryRepository_StoreConversationSummary_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEventPublisher creates a new instance of MockEventPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEventPublisher(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEventPublisher {
	mock := &MockEventPublisher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEventPublisher is an autogenerated mock type for the EventPublisher type
type MockEventPublisher struct {
	mock.Mock
}

type MockEventPublisher_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEventPublisher) EXPECT() *MockEventPublisher_Expecter {
	return &MockEventPublisher_Expecter{mock: &_m.Mock}
}

// PublishEvent provides a mock function for the type MockEventPublisher
func (_mock *MockEventPublisher) PublishEvent(ctx context.Context, event OutboxEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for PublishEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, OutboxEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockEventPublisher_PublishEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishEvent'
type MockEventPublisher_PublishEvent_Call struct {
	*mock.Call
}

// PublishEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event OutboxEvent
func (_e *MockEventPublisher_Expecter) PublishEvent(ctx interface{}, event interface{}) *MockEventPublisher_PublishEvent_Call {
	return &MockEventPublisher_PublishEvent_Call{Call: _e.mock.On("PublishEvent", ctx, event)}
}

func (_c *MockEventPublisher_PublishEvent_Call) Run(run func(ctx context.Context, event OutboxEvent)) *MockEventPublisher_PublishEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 OutboxEvent
		if args[1] != nil {
			arg1 = args[1].(OutboxEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockEventPublisher_PublishEvent_Call) Return(err error) *MockEventPublisher_PublishEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockEventPublisher_PublishEvent_Call) RunAndReturn(run func(ctx context.Context, event OutboxEvent) error) *MockEventPublisher_PublishEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOutboxRepository creates a new instance of MockOutboxRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOutboxRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOutboxRepository {
	mock := &MockOutboxRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOutboxRepository is an autogenerated mock type for the OutboxRepository type
type MockOutboxRepository struct {
	mock.Mock
}

type MockOutboxRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOutboxRepository) EXPECT() *MockOutboxRepository_Expecter {
	return &MockOutboxRepository_Expecter{mock: &_m.Mock}
}

// CreateChatEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) CreateChatEvent(ctx context.Context, event ChatMessageEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for CreateChatEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, ChatMessageEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_CreateChatEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateChatEvent'
type MockOutboxRepository_CreateChatEvent_Call struct {
	*mock.Call
}

// CreateChatEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event ChatMessageEvent
func (_e *MockOutboxRepository_Expecter) CreateChatEvent(ctx interface{}, event interface{}) *MockOutboxRepository_CreateChatEvent_Call {
	return &MockOutboxRepository_CreateChatEvent_Call{Call: _e.mock.On("CreateChatEvent", ctx, event)}
}

func (_c *MockOutboxRepository_CreateChatEvent_Call) Run(run func(ctx context.Context, event ChatMessageEvent)) *MockOutboxRepository_CreateChatEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 ChatMessageEvent
		if args[1] != nil {
			arg1 = args[1].(ChatMessageEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_CreateChatEvent_Call) Return(err error) *MockOutboxRepository_CreateChatEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_CreateChatEvent_Call) RunAndReturn(run func(ctx context.Context, event ChatMessageEvent) error) *MockOutboxRepository_CreateChatEvent_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTodoEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) CreateTodoEvent(ctx context.Context, event TodoEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for CreateTodoEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, TodoEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_CreateTodoEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTodoEvent'
type MockOutboxRepository_CreateTodoEvent_Call struct {
	*mock.Call
}

// CreateTodoEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event TodoEvent
func (_e *MockOutboxRepository_Expecter) CreateTodoEvent(ctx interface{}, event interface{}) *MockOutboxRepository_CreateTodoEvent_Call {
	return &MockOutboxRepository_CreateTodoEvent_Call{Call: _e.mock.On("CreateTodoEvent", ctx, event)}
}

func (_c *MockOutboxRepository_CreateTodoEvent_Call) Run(run func(ctx context.Context, event TodoEvent)) *MockOutboxRepository_CreateTodoEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 TodoEvent
		if args[1] != nil {
			arg1 = args[1].(TodoEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_CreateTodoEvent_Call) Return(err error) *MockOutboxRepository_CreateTodoEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_CreateTodoEvent_Call) RunAndReturn(run func(ctx context.Context, event TodoEvent) error) *MockOutboxRepository_CreateTodoEvent_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) DeleteEvent(ctx context.Context, eventID uuid.UUID) error {
	ret := _mock.Called(ctx, eventID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, eventID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_DeleteEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEvent'
type MockOutboxRepository_DeleteEvent_Call struct {
	*mock.Call
}

// DeleteEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID uuid.UUID
func (_e *MockOutboxRepository_Expecter) DeleteEvent(ctx interface{}, eventID interface{}) *MockOutboxRepository_DeleteEvent_Call {
	return &MockOutboxRepository_DeleteEvent_Call{Call: _e.mock.On("DeleteEvent", ctx, eventID)}
}

func (_c *MockOutboxRepository_DeleteEvent_Call) Run(run func(ctx context.Context, eventID uuid.UUID)) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_DeleteEvent_Call) Return(err error) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_DeleteEvent_Call) RunAndReturn(run func(ctx context.Context, eventID uuid.UUID) error) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Return(run)
	return _c
}

// FetchPendingEvents provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) FetchPendingEvents(ctx context.Context, limit int) ([]OutboxEvent, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for FetchPendingEvents")
	}

	var r0 []OutboxEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]OutboxEvent, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []OutboxEvent); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]OutboxEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOutboxRepository_FetchPendingEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchPendingEvents'
type MockOutboxRepository_FetchPendingEvents_Call struct {
	*mock.Call
}

// FetchPendingEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockOutboxRepository_Expecter) FetchPendingEvents(ctx interface{}, limit interface{}) *MockOutboxRepository_FetchPendingEvents_Call {
	return &MockOutboxRepository_FetchPendingEvents_Call{Call: _e.mock.On("FetchPendingEvents", ctx, limit)}
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) Run(run func(ctx context.Context, limit int)) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) Return(outboxEvents []OutboxEvent, err error) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Return(outboxEvents, err)
	return _c
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]OutboxEvent, error)) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) UpdateEvent(ctx context.Context, eventID uuid.UUID, status OutboxStatus, retryCount int, lastError string) error {
	ret := _mock.Called(ctx, eventID, status, retryCount, lastError)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, OutboxStatus, int, string) error); ok {
		r0 = returnFunc(ctx, eventID, status, retryCount, lastError)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_UpdateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEvent'
type MockOutboxRepository_UpdateEvent_Call struct {
	*mock.Call
}

// UpdateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID uuid.UUID
//   - status OutboxStatus
//   - retryCount int
//   - lastError string
func (_e *MockOutboxRepository_Expecter) UpdateEvent(ctx interface{}, eventID interface{}, status interface{}, retryCount interface{}, lastError interface{}) *MockOutboxRepository_UpdateEvent_Call {
	return &MockOutboxRepository_UpdateEvent_Call{Call: _e.mock.On("UpdateEvent", ctx, eventID, status, retryCount, lastError)}
}

func (_c *MockOutboxRepository_UpdateEvent_Call) Run(run func(ctx context.Context, eventID uuid.UUID, status OutboxStatus, retryCount int, lastError string)) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 OutboxStatus
		if args[2] != nil {
			arg2 = args[2].(OutboxStatus)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_UpdateEvent_Call) Return(err error) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_UpdateEvent_Call) RunAndReturn(run func(ctx context.Context, eventID uuid.UUID, status OutboxStatus, retryCount int, lastError string) error) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockSemanticEncoder creates a new instance of MockSemanticEncoder. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockSemanticEncoder(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockSemanticEncoder {
	mock := &MockSemanticEncoder{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockSemanticEncoder is an autogenerated mock type for the SemanticEncoder type
type MockSemanticEncoder struct {
	mock.Mock
}

type MockSemanticEncoder_Expecter struct {
	mock *mock.Mock
}

func (_m *MockSemanticEncoder) EXPECT() *MockSemanticEncoder_Expecter {
	return &MockSemanticEncoder_Expecter{mock: &_m.Mock}
}

// VectorizeAssistantActionDefinition provides a mock function for the type MockSemanticEncoder
func (_mock *MockSemanticEncoder) VectorizeAssistantActionDefinition(ctx context.Context, model string, action AssistantActionDefinition) (EmbeddingVector, error) {
	ret := _mock.Called(ctx, model, action)

	if len(ret) == 0 {
		panic("no return value specified for VectorizeAssistantActionDefinition")
	}

	var r0 EmbeddingVector
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, AssistantActionDefinition) (EmbeddingVector, error)); ok {
		return returnFunc(ctx, model, action)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, AssistantActionDefinition) EmbeddingVector); ok {
		r0 = returnFunc(ctx, model, action)
	} else {
		r0 = ret.Get(0).(EmbeddingVector)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, AssistantActionDefinition) error); ok {
		r1 = returnFunc(ctx, model, action)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSemanticEncoder_VectorizeAssistantActionDefinition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VectorizeAssistantActionDefinition'
type MockSemanticEncoder_VectorizeAssistantActionDefinition_Call struct {
	*mock.Call
}

// VectorizeAssistantActionDefinition is a helper method to define mock.On call
//   - ctx context.Context
//   - model string
//   - action AssistantActionDefinition
func (_e *MockSemanticEncoder_Expecter) VectorizeAssistantActionDefinition(ctx interface{}, model interface{}, action interface{}) *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call {
	return &MockSemanticEncoder_VectorizeAssistantActionDefinition_Call{Call: _e.mock.On("VectorizeAssistantActionDefinition", ctx, model, action)}
}

func (_c *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call) Run(run func(ctx context.Context, model string, action AssistantActionDefinition)) *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 AssistantActionDefinition
		if args[2] != nil {
			arg2 = args[2].(AssistantActionDefinition)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call) Return(embeddingVector EmbeddingVector, err error) *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call {
	_c.Call.Return(embeddingVector, err)
	return _c
}

func (_c *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call) RunAndReturn(run func(ctx context.Context, model string, action AssistantActionDefinition) (EmbeddingVector, error)) *MockSemanticEncoder_VectorizeAssistantActionDefinition_Call {
	_c.Call.Return(run)
	return _c
}

// VectorizeQuery provides a mock function for the type MockSemanticEncoder
func (_mock *MockSemanticEncoder) VectorizeQuery(ctx context.Context, model string, query string) (EmbeddingVector, error) {
	ret := _mock.Called(ctx, model, query)

	if len(ret) == 0 {
		panic("no return value specified for VectorizeQuery")
	}

	var r0 EmbeddingVector
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (EmbeddingVector, error)); ok {
		return returnFunc(ctx, model, query)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) EmbeddingVector); ok {
		r0 = returnFunc(ctx, model, query)
	} else {
		r0 = ret.Get(0).(EmbeddingVector)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, model, query)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSemanticEncoder_VectorizeQuery_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VectorizeQuery'
type MockSemanticEncoder_VectorizeQuery_Call struct {
	*mock.Call
}

// VectorizeQuery is a helper method to define mock.On call
//   - ctx context.Context
//   - model string
//   - query string
func (_e *MockSemanticEncoder_Expecter) VectorizeQuery(ctx interface{}, model interface{}, query interface{}) *MockSemanticEncoder_VectorizeQuery_Call {
	return &MockSemanticEncoder_VectorizeQuery_Call{Call: _e.mock.On("VectorizeQuery", ctx, model, query)}
}

func (_c *MockSemanticEncoder_VectorizeQuery_Call) Run(run func(ctx context.Context, model string, query string)) *MockSemanticEncoder_VectorizeQuery_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSemanticEncoder_VectorizeQuery_Call) Return(embeddingVector EmbeddingVector, err error) *MockSemanticEncoder_VectorizeQuery_Call {
	_c.Call.Return(embeddingVector, err)
	return _c
}

func (_c *MockSemanticEncoder_VectorizeQuery_Call) RunAndReturn(run func(ctx context.Context, model string, query string) (EmbeddingVector, error)) *MockSemanticEncoder_VectorizeQuery_Call {
	_c.Call.Return(run)
	return _c
}

// VectorizeTodo provides a mock function for the type MockSemanticEncoder
func (_mock *MockSemanticEncoder) VectorizeTodo(ctx context.Context, model string, todo Todo) (EmbeddingVector, error) {
	ret := _mock.Called(ctx, model, todo)

	if len(ret) == 0 {
		panic("no return value specified for VectorizeTodo")
	}

	var r0 EmbeddingVector
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, Todo) (EmbeddingVector, error)); ok {
		return returnFunc(ctx, model, todo)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, Todo) EmbeddingVector); ok {
		r0 = returnFunc(ctx, model, todo)
	} else {
		r0 = ret.Get(0).(EmbeddingVector)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, Todo) error); ok {
		r1 = returnFunc(ctx, model, todo)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockSemanticEncoder_VectorizeTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'VectorizeTodo'
type MockSemanticEncoder_VectorizeTodo_Call struct {
	*mock.Call
}

// VectorizeTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - model string
//   - todo Todo
func (_e *MockSemanticEncoder_Expecter) VectorizeTodo(ctx interface{}, model interface{}, todo interface{}) *MockSemanticEncoder_VectorizeTodo_Call {
	return &MockSemanticEncoder_VectorizeTodo_Call{Call: _e.mock.On("VectorizeTodo", ctx, model, todo)}
}

func (_c *MockSemanticEncoder_VectorizeTodo_Call) Run(run func(ctx context.Context, model string, todo Todo)) *MockSemanticEncoder_VectorizeTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 Todo
		if args[2] != nil {
			arg2 = args[2].(Todo)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockSemanticEncoder_VectorizeTodo_Call) Return(embeddingVector EmbeddingVector, err error) *MockSemanticEncoder_VectorizeTodo_Call {
	_c.Call.Return(embeddingVector, err)
	return _c
}

func (_c *MockSemanticEncoder_VectorizeTodo_Call) RunAndReturn(run func(ctx context.Context, model string, todo Todo) (EmbeddingVector, error)) *MockSemanticEncoder_VectorizeTodo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockEmbeddingModelCatalog creates a new instance of MockEmbeddingModelCatalog. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockEmbeddingModelCatalog(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockEmbeddingModelCatalog {
	mock := &MockEmbeddingModelCatalog{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockEmbeddingModelCatalog is an autogenerated mock type for the EmbeddingModelCatalog type
type MockEmbeddingModelCatalog struct {
	mock.Mock
}

type MockEmbeddingModelCatalog_Expecter struct {
	mock *mock.Mock
}

func (_m *MockEmbeddingModelCatalog) EXPECT() *MockEmbeddingModelCatalog_Expecter {
	return &MockEmbeddingModelCatalog_Expecter{mock: &_m.Mock}
}

// ListEmbeddingModels provides a mock function for the type MockEmbeddingModelCatalog
func (_mock *MockEmbeddingModelCatalog) ListEmbeddingModels(ctx context.Context) ([]EmbeddingModelInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for ListEmbeddingModels")
	}

	var r0 []EmbeddingModelInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]EmbeddingModelInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []EmbeddingModelInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]EmbeddingModelInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockEmbeddingModelCatalog_ListEmbeddingModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListEmbeddingModels'
type MockEmbeddingModelCatalog_ListEmbeddingModels_Call struct {
	*mock.Call
}

// ListEmbeddingModels is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockEmbeddingModelCatalog_Expecter) ListEmbeddingModels(ctx interface{}) *MockEmbeddingModelCatalog_ListEmbeddingModels_Call {
	return &MockEmbeddingModelCatalog_ListEmbeddingModels_Call{Call: _e.mock.On("ListEmbeddingModels", ctx)}
}

func (_c *MockEmbeddingModelCatalog_ListEmbeddingModels_Call) Run(run func(ctx context.Context)) *MockEmbeddingModelCatalog_ListEmbeddingModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockEmbeddingModelCatalog_ListEmbeddingModels_Call) Return(embeddingModelInfos []EmbeddingModelInfo, err error) *MockEmbeddingModelCatalog_ListEmbeddingModels_Call {
	_c.Call.Return(embeddingModelInfos, err)
	return _c
}

func (_c *MockEmbeddingModelCatalog_ListEmbeddingModels_Call) RunAndReturn(run func(ctx context.Context) ([]EmbeddingModelInfo, error)) *MockEmbeddingModelCatalog_ListEmbeddingModels_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCurrentTimeProvider creates a new instance of MockCurrentTimeProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCurrentTimeProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCurrentTimeProvider {
	mock := &MockCurrentTimeProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCurrentTimeProvider is an autogenerated mock type for the CurrentTimeProvider type
type MockCurrentTimeProvider struct {
	mock.Mock
}

type MockCurrentTimeProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCurrentTimeProvider) EXPECT() *MockCurrentTimeProvider_Expecter {
	return &MockCurrentTimeProvider_Expecter{mock: &_m.Mock}
}

// Now provides a mock function for the type MockCurrentTimeProvider
func (_mock *MockCurrentTimeProvider) Now() time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Now")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func() time.Time); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// MockCurrentTimeProvider_Now_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Now'
type MockCurrentTimeProvider_Now_Call struct {
	*mock.Call
}

// Now is a helper method to define mock.On call
func (_e *MockCurrentTimeProvider_Expecter) Now() *MockCurrentTimeProvider_Now_Call {
	return &MockCurrentTimeProvider_Now_Call{Call: _e.mock.On("Now")}
}

func (_c *MockCurrentTimeProvider_Now_Call) Run(run func()) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCurrentTimeProvider_Now_Call) Return(time1 time.Time) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockCurrentTimeProvider_Now_Call) RunAndReturn(run func() time.Time) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTodoRepository creates a new instance of MockTodoRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTodoRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTodoRepository {
	mock := &MockTodoRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTodoRepository is an autogenerated mock type for the TodoRepository type
type MockTodoRepository struct {
	mock.Mock
}

type MockTodoRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTodoRepository) EXPECT() *MockTodoRepository_Expecter {
	return &MockTodoRepository_Expecter{mock: &_m.Mock}
}

// CreateTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) CreateTodo(ctx context.Context, todo Todo) error {
	ret := _mock.Called(ctx, todo)

	if len(ret) == 0 {
		panic("no return value specified for CreateTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Todo) error); ok {
		r0 = returnFunc(ctx, todo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_CreateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTodo'
type MockTodoRepository_CreateTodo_Call struct {
	*mock.Call
}

// CreateTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - todo Todo
func (_e *MockTodoRepository_Expecter) CreateTodo(ctx interface{}, todo interface{}) *MockTodoRepository_CreateTodo_Call {
	return &MockTodoRepository_CreateTodo_Call{Call: _e.mock.On("CreateTodo", ctx, todo)}
}

func (_c *MockTodoRepository_CreateTodo_Call) Run(run func(ctx context.Context, todo Todo)) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Todo
		if args[1] != nil {
			arg1 = args[1].(Todo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_CreateTodo_Call) Return(err error) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_CreateTodo_Call) RunAndReturn(run func(ctx context.Context, todo Todo) error) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) DeleteTodo(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_DeleteTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTodo'
type MockTodoRepository_DeleteTodo_Call struct {
	*mock.Call
}

// DeleteTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockTodoRepository_Expecter) DeleteTodo(ctx interface{}, id interface{}) *MockTodoRepository_DeleteTodo_Call {
	return &MockTodoRepository_DeleteTodo_Call{Call: _e.mock.On("DeleteTodo", ctx, id)}
}

func (_c *MockTodoRepository_DeleteTodo_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_DeleteTodo_Call) Return(err error) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_DeleteTodo_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) GetTodo(ctx context.Context, id uuid.UUID) (Todo, bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTodo")
	}

	var r0 Todo
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (Todo, bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) Todo); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(Todo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) bool); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok {
		r2 = returnFunc(ctx, id)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTodoRepository_GetTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTodo'
type MockTodoRepository_GetTodo_Call struct {
	*mock.Call
}

// GetTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockTodoRepository_Expecter) GetTodo(ctx interface{}, id interface{}) *MockTodoRepository_GetTodo_Call {
	return &MockTodoRepository_GetTodo_Call{Call: _e.mock.On("GetTodo", ctx, id)}
}

func (_c *MockTodoRepository_GetTodo_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockTodoRepository_GetTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_GetTodo_Call) Return(todo Todo, b bool, err error) *MockTodoRepository_GetTodo_Call {
	_c.Call.Return(todo, b, err)
	return _c
}

func (_c *MockTodoRepository_GetTodo_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (Todo, bool, error)) *MockTodoRepository_GetTodo_Call {
	_c.Call.Return(run)
	return _c
}

// ListTodos provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) ListTodos(ctx context.Context, page int, pageSize int, opts ...ListTodoOption) ([]Todo, bool, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, page, pageSize, opts)
	} else {
		tmpRet = _mock.Called(ctx, page, pageSize)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListTodos")
	}

	var r0 []Todo
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...ListTodoOption) ([]Todo, bool, error)); ok {
		return returnFunc(ctx, page, pageSize, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...ListTodoOption) []Todo); ok {
		r0 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Todo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int, ...ListTodoOption) bool); ok {
		r1 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int, ...ListTodoOption) error); ok {
		r2 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTodoRepository_ListTodos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTodos'
type MockTodoRepository_ListTodos_Call struct {
	*mock.Call
}

// ListTodos is a helper method to define mock.On call
//   - ctx context.Context
//   - page int
//   - pageSize int
//   - opts ...ListTodoOption
func (_e *MockTodoRepository_Expecter) ListTodos(ctx interface{}, page interface{}, pageSize interface{}, opts ...interface{}) *MockTodoRepository_ListTodos_Call {
	return &MockTodoRepository_ListTodos_Call{Call: _e.mock.On("ListTodos",
		append([]interface{}{ctx, page, pageSize}, opts...)...)}
}

func (_c *MockTodoRepository_ListTodos_Call) Run(run func(ctx context.Context, page int, pageSize int, opts ...ListTodoOption)) *MockTodoRepository_ListTodos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 []ListTodoOption
		var variadicArgs []ListTodoOption
		if len(args) > 3 {
			variadicArgs = args[3].([]ListTodoOption)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockTodoRepository_ListTodos_Call) Return(todos []Todo, b bool, err error) *MockTodoRepository_ListTodos_Call {
	_c.Call.Return(todos, b, err)
	return _c
}

func (_c *MockTodoRepository_ListTodos_Call) RunAndReturn(run func(ctx context.Context, page int, pageSize int, opts ...ListTodoOption) ([]Todo, bool, error)) *MockTodoRepository_ListTodos_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) UpdateTodo(ctx context.Context, todo Todo) error {
	ret := _mock.Called(ctx, todo)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Todo) error); ok {
		r0 = returnFunc(ctx, todo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_UpdateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTodo'
type MockTodoRepository_UpdateTodo_Call struct {
	*mock.Call
}

// UpdateTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - todo Todo
func (_e *MockTodoRepository_Expecter) UpdateTodo(ctx interface{}, todo interface{}) *MockTodoRepository_UpdateTodo_Call {
	return &MockTodoRepository_UpdateTodo_Call{Call: _e.mock.On("UpdateTodo", ctx, todo)}
}

func (_c *MockTodoRepository_UpdateTodo_Call) Run(run func(ctx context.Context, todo Todo)) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Todo
		if args[1] != nil {
			arg1 = args[1].(Todo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_UpdateTodo_Call) Return(err error) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_UpdateTodo_Call) RunAndReturn(run func(ctx context.Context, todo Todo) error) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBoardSummaryRepository creates a new instance of MockBoardSummaryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBoardSummaryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBoardSummaryRepository {
	mock := &MockBoardSummaryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBoardSummaryRepository is an autogenerated mock type for the BoardSummaryRepository type
type MockBoardSummaryRepository struct {
	mock.Mock
}

type MockBoardSummaryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBoardSummaryRepository) EXPECT() *MockBoardSummaryRepository_Expecter {
	return &MockBoardSummaryRepository_Expecter{mock: &_m.Mock}
}

// CalculateSummaryContent provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) CalculateSummaryContent(ctx context.Context) (BoardSummaryContent, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CalculateSummaryContent")
	}

	var r0 BoardSummaryContent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (BoardSummaryContent, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) BoardSummaryContent); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(BoardSummaryContent)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBoardSummaryRepository_CalculateSummaryContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalculateSummaryContent'
type MockBoardSummaryRepository_CalculateSummaryContent_Call struct {
	*mock.Call
}

// CalculateSummaryContent is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBoardSummaryRepository_Expecter) CalculateSummaryContent(ctx interface{}) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	return &MockBoardSummaryRepository_CalculateSummaryContent_Call{Call: _e.mock.On("CalculateSummaryContent", ctx)}
}

func (_c *MockBoardSummaryRepository_CalculateSummaryContent_Call) Run(run func(ctx context.Context)) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_CalculateSummaryContent_Call) Return(boardSummaryContent BoardSummaryContent, err error) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	_c.Call.Return(boardSummaryContent, err)
	return _c
}

func (_c *MockBoardSummaryRepository_CalculateSummaryContent_Call) RunAndReturn(run func(ctx context.Context) (BoardSummaryContent, error)) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestSummary provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) GetLatestSummary(ctx context.Context) (BoardSummary, bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestSummary")
	}

	var r0 BoardSummary
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (BoardSummary, bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) BoardSummary); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(BoardSummary)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = returnFunc(ctx)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockBoardSummaryRepository_GetLatestSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestSummary'
type MockBoardSummaryRepository_GetLatestSummary_Call struct {
	*mock.Call
}

// GetLatestSummary is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBoardSummaryRepository_Expecter) GetLatestSummary(ctx interface{}) *MockBoardSummaryRepository_GetLatestSummary_Call {
	return &MockBoardSummaryRepository_GetLatestSummary_Call{Call: _e.mock.On("GetLatestSummary", ctx)}
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) Run(run func(ctx context.Context)) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) Return(boardSummary BoardSummary, b bool, err error) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Return(boardSummary, b, err)
	return _c
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) RunAndReturn(run func(ctx context.Context) (BoardSummary, bool, error)) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Return(run)
	return _c
}

// StoreSummary provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) StoreSummary(ctx context.Context, summary BoardSummary) error {
	ret := _mock.Called(ctx, summary)

	if len(ret) == 0 {
		panic("no return value specified for StoreSummary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, BoardSummary) error); ok {
		r0 = returnFunc(ctx, summary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBoardSummaryRepository_StoreSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreSummary'
type MockBoardSummaryRepository_StoreSummary_Call struct {
	*mock.Call
}

// StoreSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - summary BoardSummary
func (_e *MockBoardSummaryRepository_Expecter) StoreSummary(ctx interface{}, summary interface{}) *MockBoardSummaryRepository_StoreSummary_Call {
	return &MockBoardSummaryRepository_StoreSummary_Call{Call: _e.mock.On("StoreSummary", ctx, summary)}
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) Run(run func(ctx context.Context, summary BoardSummary)) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 BoardSummary
		if args[1] != nil {
			arg1 = args[1].(BoardSummary)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) Return(err error) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) RunAndReturn(run func(ctx context.Context, summary BoardSummary) error) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUnitOfWork creates a new instance of MockUnitOfWork. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUnitOfWork(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUnitOfWork {
	mock := &MockUnitOfWork{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUnitOfWork is an autogenerated mock type for the UnitOfWork type
type MockUnitOfWork struct {
	mock.Mock
}

type MockUnitOfWork_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUnitOfWork) EXPECT() *MockUnitOfWork_Expecter {
	return &MockUnitOfWork_Expecter{mock: &_m.Mock}
}

// ChatMessage provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) ChatMessage() ChatMessageRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ChatMessage")
	}

	var r0 ChatMessageRepository
	if returnFunc, ok := ret.Get(0).(func() ChatMessageRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ChatMessageRepository)
		}
	}
	return r0
}

// MockUnitOfWork_ChatMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChatMessage'
type MockUnitOfWork_ChatMessage_Call struct {
	*mock.Call
}

// ChatMessage is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) ChatMessage() *MockUnitOfWork_ChatMessage_Call {
	return &MockUnitOfWork_ChatMessage_Call{Call: _e.mock.On("ChatMessage")}
}

func (_c *MockUnitOfWork_ChatMessage_Call) Run(run func()) *MockUnitOfWork_ChatMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_ChatMessage_Call) Return(chatMessageRepository ChatMessageRepository) *MockUnitOfWork_ChatMessage_Call {
	_c.Call.Return(chatMessageRepository)
	return _c
}

func (_c *MockUnitOfWork_ChatMessage_Call) RunAndReturn(run func() ChatMessageRepository) *MockUnitOfWork_ChatMessage_Call {
	_c.Call.Return(run)
	return _c
}

// Conversation provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Conversation() ConversationRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Conversation")
	}

	var r0 ConversationRepository
	if returnFunc, ok := ret.Get(0).(func() ConversationRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ConversationRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Conversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Conversation'
type MockUnitOfWork_Conversation_Call struct {
	*mock.Call
}

// Conversation is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Conversation() *MockUnitOfWork_Conversation_Call {
	return &MockUnitOfWork_Conversation_Call{Call: _e.mock.On("Conversation")}
}

func (_c *MockUnitOfWork_Conversation_Call) Run(run func()) *MockUnitOfWork_Conversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Conversation_Call) Return(conversationRepository ConversationRepository) *MockUnitOfWork_Conversation_Call {
	_c.Call.Return(conversationRepository)
	return _c
}

func (_c *MockUnitOfWork_Conversation_Call) RunAndReturn(run func() ConversationRepository) *MockUnitOfWork_Conversation_Call {
	_c.Call.Return(run)
	return _c
}

// ConversationSummary provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) ConversationSummary() ConversationSummaryRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for ConversationSummary")
	}

	var r0 ConversationSummaryRepository
	if returnFunc, ok := ret.Get(0).(func() ConversationSummaryRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(ConversationSummaryRepository)
		}
	}
	return r0
}

// MockUnitOfWork_ConversationSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ConversationSummary'
type MockUnitOfWork_ConversationSummary_Call struct {
	*mock.Call
}

// ConversationSummary is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) ConversationSummary() *MockUnitOfWork_ConversationSummary_Call {
	return &MockUnitOfWork_ConversationSummary_Call{Call: _e.mock.On("ConversationSummary")}
}

func (_c *MockUnitOfWork_ConversationSummary_Call) Run(run func()) *MockUnitOfWork_ConversationSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_ConversationSummary_Call) Return(conversationSummaryRepository ConversationSummaryRepository) *MockUnitOfWork_ConversationSummary_Call {
	_c.Call.Return(conversationSummaryRepository)
	return _c
}

func (_c *MockUnitOfWork_ConversationSummary_Call) RunAndReturn(run func() ConversationSummaryRepository) *MockUnitOfWork_ConversationSummary_Call {
	_c.Call.Return(run)
	return _c
}

// Execute provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Execute(ctx context.Context, fn func(uow UnitOfWork) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(uow UnitOfWork) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUnitOfWork_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUnitOfWork_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(uow UnitOfWork) error
func (_e *MockUnitOfWork_Expecter) Execute(ctx interface{}, fn interface{}) *MockUnitOfWork_Execute_Call {
	return &MockUnitOfWork_Execute_Call{Call: _e.mock.On("Execute", ctx, fn)}
}

func (_c *MockUnitOfWork_Execute_Call) Run(run func(ctx context.Context, fn func(uow UnitOfWork) error)) *MockUnitOfWork_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(uow UnitOfWork) error
		if args[1] != nil {
			arg1 = args[1].(func(uow UnitOfWork) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUnitOfWork_Execute_Call) Return(err error) *MockUnitOfWork_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUnitOfWork_Execute_Call) RunAndReturn(run func(ctx context.Context, fn func(uow UnitOfWork) error) error) *MockUnitOfWork_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// Outbox provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Outbox() OutboxRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Outbox")
	}

	var r0 OutboxRepository
	if returnFunc, ok := ret.Get(0).(func() OutboxRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(OutboxRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Outbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Outbox'
type MockUnitOfWork_Outbox_Call struct {
	*mock.Call
}

// Outbox is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Outbox() *MockUnitOfWork_Outbox_Call {
	return &MockUnitOfWork_Outbox_Call{Call: _e.mock.On("Outbox")}
}

func (_c *MockUnitOfWork_Outbox_Call) Run(run func()) *MockUnitOfWork_Outbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Outbox_Call) Return(outboxRepository OutboxRepository) *MockUnitOfWork_Outbox_Call {
	_c.Call.Return(outboxRepository)
	return _c
}

func (_c *MockUnitOfWork_Outbox_Call) RunAndReturn(run func() OutboxRepository) *MockUnitOfWork_Outbox_Call {
	_c.Call.Return(run)
	return _c
}

// Todo provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Todo() TodoRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Todo")
	}

	var r0 TodoRepository
	if returnFunc, ok := ret.Get(0).(func() TodoRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(TodoRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Todo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Todo'
type MockUnitOfWork_Todo_Call struct {
	*mock.Call
}

// Todo is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Todo() *MockUnitOfWork_Todo_Call {
	return &MockUnitOfWork_Todo_Call{Call: _e.mock.On("Todo")}
}

func (_c *MockUnitOfWork_Todo_Call) Run(run func()) *MockUnitOfWork_Todo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Todo_Call) Return(todoRepository TodoRepository) *MockUnitOfWork_Todo_Call {
	_c.Call.Return(todoRepository)
	return _c
}

func (_c *MockUnitOfWork_Todo_Call) RunAndReturn(run func() TodoRepository) *MockUnitOfWork_Todo_Call {
	_c.Call.Return(run)
	return _c
}
