package domain

import (
	"context"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/google/uuid"
)

// BoardSummaryRepository defines the interface for storing and retrieving board summaries.
type BoardSummaryRepository interface {
	// StoreSummary saves a new board summary to the repository.
	StoreSummary(ctx context.Context, summary BoardSummary) error
	// CalculateSummaryContent computes the summary content based on the current state of the todo board.
	CalculateSummaryContent(ctx context.Context) (BoardSummaryContent, error)
	// GetLatestSummary retrieves the most recent board summary, returning a boolean indicating if a summary exists.
	GetLatestSummary(ctx context.Context) (BoardSummary, bool, error)
}

// BoardSummary represents a summary of the todo board generated by an LLM.
type BoardSummary struct {
	ID            uuid.UUID
	Content       BoardSummaryContent
	Model         string
	GeneratedAt   time.Time
	SourceVersion int64
}

// ComparisonHints holds the computed hints for comparing board summaries.
type ComparisonHints struct {
	CompletedCandidates []string
	DoneDelta           int
	OverdueTitles       string
	NearDeadlineTitles  string
	NextUpOverdue       string
	NextUpDueSoon       string
	NextUpUpcoming      string
	NextUpFuture        string
}

// BoardSummaryContent holds the content of the board summary.
type BoardSummaryContent struct {
	Counts       TodoStatusCounts `json:"counts"`
	NextUp       []NextUpTodoItem `json:"next_up"`
	Overdue      []string         `json:"overdue"`
	NearDeadline []string         `json:"near_deadline"`
	Summary      string           `json:"summary"`
}

// DiffersFrom compares the new summary content with the previous one and returns true if they differ significantly.
func (new BoardSummaryContent) DiffersFrom(previous BoardSummaryContent) bool {
	return new.Counts != previous.Counts ||
		!slices.Equal(new.NextUp, previous.NextUp) ||
		!slices.Equal(new.Overdue, previous.Overdue) ||
		!slices.Equal(new.NearDeadline, previous.NearDeadline)
}

var (
	reNoOverdueTasks    = regexp.MustCompile(`(?i)\bno overdue tasks?\b`)
	reNoTasksAreOverdue = regexp.MustCompile(`(?i)\bno tasks are overdue\b`)
	reNothingIsOverdue  = regexp.MustCompile(`(?i)\bnothing is overdue\b`)
	reOverdueQualifier  = regexp.MustCompile(`(?i)\boverdue\s+`)
	reLateQualifier     = regexp.MustCompile(`(?i)\blate\s+`)
	rePastDueQualifier  = regexp.MustCompile(`(?i)\bpast[- ]due\s+`)
	reExtraSpaces       = regexp.MustCompile(`\s{2,}`)
	reSpaceBeforePunct  = regexp.MustCompile(`\s+([,.;:!?])`)
)

// ApplySummary applies a generated summary to the content while enforcing
// domain safety guards based on current board facts.
func (c *BoardSummaryContent) ApplySummary(summary string) {
	cleaned := strings.TrimSpace(summary)
	if cleaned == "" {
		c.Summary = cleaned
		return
	}

	// Prevent markdown formatting from leaking into the final summary text.
	cleaned = strings.ReplaceAll(cleaned, "**", "")
	// If there are no overdue tasks in current facts, remove unsupported
	// overdue/late qualifiers while preserving explicit "no overdue" statements.
	if len(c.Overdue) == 0 {
		cleaned = reNoOverdueTasks.ReplaceAllString(cleaned, "__NO_OVERDUE_TASKS__")
		cleaned = reNoTasksAreOverdue.ReplaceAllString(cleaned, "__NO_TASKS_ARE_OVERDUE__")
		cleaned = reNothingIsOverdue.ReplaceAllString(cleaned, "__NOTHING_IS_OVERDUE__")

		cleaned = reOverdueQualifier.ReplaceAllString(cleaned, "")
		cleaned = reLateQualifier.ReplaceAllString(cleaned, "")
		cleaned = rePastDueQualifier.ReplaceAllString(cleaned, "")
		cleaned = reExtraSpaces.ReplaceAllString(cleaned, " ")
		cleaned = reSpaceBeforePunct.ReplaceAllString(cleaned, "$1")
		cleaned = strings.TrimSpace(cleaned)

		cleaned = strings.ReplaceAll(cleaned, "__NO_OVERDUE_TASKS__", "no overdue tasks")
		cleaned = strings.ReplaceAll(cleaned, "__NO_TASKS_ARE_OVERDUE__", "no tasks are overdue")
		cleaned = strings.ReplaceAll(cleaned, "__NOTHING_IS_OVERDUE__", "nothing is overdue")
	}

	c.Summary = cleaned
}

// BuildComparisonHints computes hints by comparing this content with a previous version.
func (c BoardSummaryContent) BuildComparisonHints(previous BoardSummaryContent) ComparisonHints {
	// Completed progress hints
	doneDelta := c.Counts.Done - previous.Counts.Done
	completedCandidates := c.extractCompletedCandidates(previous)

	// Urgency hints
	overdueTitles := normalizeTitles(c.Overdue)
	nearDeadlineTitles := normalizeTitles(c.NearDeadline)

	nextUpOverdue, nextUpDueSoon, nextUpUpcoming, nextUpFuture := c.categorizeNextUpItems()

	return ComparisonHints{
		CompletedCandidates: completedCandidates,
		DoneDelta:           doneDelta,
		OverdueTitles:       overdueTitles,
		NearDeadlineTitles:  nearDeadlineTitles,
		NextUpOverdue:       nextUpOverdue,
		NextUpDueSoon:       nextUpDueSoon,
		NextUpUpcoming:      nextUpUpcoming,
		NextUpFuture:        nextUpFuture,
	}
}

// extractCompletedCandidates identifies which todo items were likely completed since the last summary by comparing titles.
func (c BoardSummaryContent) extractCompletedCandidates(previous BoardSummaryContent) []string {
	currentTitles := make(map[string]struct{})
	addSummaryTitles(currentTitles, c)

	previousTitles := make(map[string]struct{})
	addSummaryTitles(previousTitles, previous)

	var candidates []string
	for title := range previousTitles {
		if _, exists := currentTitles[title]; !exists {
			candidates = append(candidates, title)
		}
	}
	slices.Sort(candidates)
	return candidates
}

// categorizeNextUpItems categorizes next up items based on their reason into overdue, due soon, upcoming, and future buckets.
func (c BoardSummaryContent) categorizeNextUpItems() (overdue, dueSoon, upcoming, future string) {
	nextUpOverdue := []string{}
	nextUpDueSoon := []string{}
	nextUpUpcoming := []string{}
	nextUpFuture := []string{}

	for _, item := range c.NextUp {
		title := strings.TrimSpace(item.Title)
		if title == "" {
			continue
		}
		switch strings.ToLower(item.Reason) {
		case "overdue":
			nextUpOverdue = append(nextUpOverdue, title)
		case "due within 7 days":
			nextUpDueSoon = append(nextUpDueSoon, title)
		case "upcoming":
			nextUpUpcoming = append(nextUpUpcoming, title)
		case "future":
			nextUpFuture = append(nextUpFuture, title)
		}
	}

	return normalizeTitles(nextUpOverdue),
		normalizeTitles(nextUpDueSoon),
		normalizeTitles(nextUpUpcoming),
		normalizeTitles(nextUpFuture)
}

// TodoStatusCounts holds the counts of todos by their status.
type TodoStatusCounts struct {
	Open int `json:"OPEN"`
	Done int `json:"DONE"`
	// If you later add more statuses, add fields here to keep JSON stable.
}

// NextUpTodoItem represents a todo item that is next up to be done.
type NextUpTodoItem struct {
	Title  string `json:"title"`
	Reason string `json:"reason"`
}

// normalizeTitles trims whitespace, removes empty titles, deduplicates,
// sorts the list of titles, and joins them into a single string.
func normalizeTitles(titles []string) string {
	if len(titles) == 0 {
		return "none"
	}

	uniq := make(map[string]struct{}, len(titles))
	for _, title := range titles {
		trimmed := strings.TrimSpace(title)
		if trimmed == "" {
			continue
		}
		uniq[trimmed] = struct{}{}
	}

	items := make([]string, 0, len(uniq))
	for title := range uniq {
		items = append(items, title)
	}
	slices.Sort(items)

	return strings.Join(items, "; ")
}

// addSummaryTitles adds the titles of summary items to the provided map for easy lookup.
func addSummaryTitles(dst map[string]struct{}, content BoardSummaryContent) {
	for _, item := range content.NextUp {
		if trimmed := strings.TrimSpace(item.Title); trimmed != "" {
			dst[trimmed] = struct{}{}
		}
	}

	for _, title := range slices.Concat(
		content.Overdue,
		content.NearDeadline,
	) {
		if trimmed := strings.TrimSpace(title); trimmed != "" {
			dst[trimmed] = struct{}{}
		}
	}
}
