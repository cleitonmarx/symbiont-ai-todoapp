package domain

import (
	"context"
	"fmt"
	"strings"
	"time"
	"unicode"

	"github.com/google/uuid"
)

// maxConversationTitleChars defines the maximum number of characters allowed in a conversation title.
const maxConversationTitleChars = 72

// ConversationTitleSource represents the source of a conversation title.
type ConversationTitleSource string

const (
	// ConversationTitleSource_User indicates the title was set by the user.
	ConversationTitleSource_User ConversationTitleSource = "user"
	// ConversationTitleSource_LLM indicates the title was generated by an LLM.
	ConversationTitleSource_LLM ConversationTitleSource = "llm"
	// ConversationTitleSource_Auto indicates the title was automatically generated based on the user's initial message.
	ConversationTitleSource_Auto ConversationTitleSource = "auto"
)

// ConversationTitleApplyStatus represents the result of attempting to apply an LLM-generated title to a conversation.
type ConversationTitleApplyStatus string

const (
	// ConversationTitleApplyStatus_Updated indicates the conversation title was successfully updated with the LLM-generated title.
	ConversationTitleApplyStatus_Updated ConversationTitleApplyStatus = "updated"
	// ConversationTitleApplyStatus_SkippedNotEligible indicates the conversation
	// was not eligible for LLM title updates (e.g. user-defined title source).
	ConversationTitleApplyStatus_SkippedNotEligible ConversationTitleApplyStatus = "skipped_not_eligible"
	// ConversationTitleApplyStatus_SkippedEmpty indicates the generated title was
	// empty and therefore not applied.
	ConversationTitleApplyStatus_SkippedEmpty ConversationTitleApplyStatus = "skipped_empty"
	// ConversationTitleApplyStatus_SkippedUnchanged indicates the generated title was
	// identical to the existing title, ignoring case and whitespace.
	ConversationTitleApplyStatus_SkippedUnchanged ConversationTitleApplyStatus = "skipped_unchanged"
	// ConversationTitleApplyStatus_SkippedNotGrounded indicates the generated title was
	// rejected for low grounding in the conversation summary.
	ConversationTitleApplyStatus_SkippedNotGrounded ConversationTitleApplyStatus = "skipped_not_grounded"
)

// Conversation represents a chat conversation, which can have multiple messages and a title.
type Conversation struct {
	ID            uuid.UUID
	Title         string
	TitleSource   ConversationTitleSource
	LastMessageAt *time.Time
	CreatedAt     time.Time
	UpdatedAt     time.Time
}

// Validate checks if the conversation has valid data.
func (c Conversation) Validate() error {
	if c.Title == "" {
		return NewValidationErr("conversation title cannot be empty")
	}
	if c.TitleSource != ConversationTitleSource_User &&
		c.TitleSource != ConversationTitleSource_LLM &&
		c.TitleSource != ConversationTitleSource_Auto {
		return NewValidationErr(fmt.Sprintf("invalid conversation title source: %s", c.TitleSource))
	}
	return nil
}

// CanBeLLMRetitled returns whether this conversation is eligible for automatic LLM title updates.
func (c Conversation) CanBeLLMRetitled() bool {
	return c.TitleSource == ConversationTitleSource_Auto
}

// ApplyUserTitle applies a user-provided title to the conversation and validates
// the resulting entity state before mutating the receiver.
func (c *Conversation) ApplyUserTitle(title string) error {
	updated := *c
	updated.Title = title
	updated.TitleSource = ConversationTitleSource_User
	if err := updated.Validate(); err != nil {
		return err
	}

	c.Title = updated.Title
	c.TitleSource = updated.TitleSource
	return nil
}

// ApplyLLMGeneratedTitle normalizes and validates an LLM-generated title, returning an updated
// conversation when the title should be applied.
func (c *Conversation) ApplyLLMGeneratedTitle(rawTitle, focusedSummary string) ConversationTitleApplyStatus {
	if !c.CanBeLLMRetitled() {
		return ConversationTitleApplyStatus_SkippedNotEligible
	}

	title := normalizeGeneratedConversationTitle(rawTitle)
	if title != "" && !isGeneratedTitleGroundedInSummary(title, focusedSummary) {
		return ConversationTitleApplyStatus_SkippedNotGrounded
	}
	if title == "" || strings.EqualFold(title, c.Title) {
		if title == "" {
			return ConversationTitleApplyStatus_SkippedEmpty
		}
		return ConversationTitleApplyStatus_SkippedUnchanged
	}

	c.Title = title
	c.TitleSource = ConversationTitleSource_LLM
	return ConversationTitleApplyStatus_Updated
}

// ConversationRepository defines the interface for managing conversations.
type ConversationRepository interface {
	// CreateConversation creates a new conversation with the given title and returns it.
	CreateConversation(context.Context, string, ConversationTitleSource) (Conversation, error)
	// GetConversation returns the conversation with the given ID, a boolean indicating if it was found, and an error if any.
	GetConversation(context.Context, uuid.UUID) (Conversation, bool, error)
	// UpdateConversation updates the conversation with the given ID.
	UpdateConversation(context.Context, Conversation) error
	// ListConversations returns a list of conversations with pagination support ordered by last message time descending.
	ListConversations(ctx context.Context, page int, pageSize int) ([]Conversation, bool, error)
	// DeleteConversation deletes the conversation with the given ID.
	DeleteConversation(context.Context, uuid.UUID) error
}

// normalizeGeneratedConversationTitle cleans up an LLM-generated title and enforces constraints.
func normalizeGeneratedConversationTitle(title string) string {
	sanitized := strings.TrimSpace(title)
	if sanitized == "" {
		return ""
	}

	// Reject list-style or multi-line outputs.
	nonEmptyLines := make([]string, 0, 4)
	for _, line := range strings.Split(sanitized, "\n") {
		line = strings.TrimSpace(line)
		if line != "" {
			nonEmptyLines = append(nonEmptyLines, line)
		}
	}
	if len(nonEmptyLines) == 0 {
		return ""
	}
	if len(nonEmptyLines) > 1 {
		return ""
	}
	sanitized = nonEmptyLines[0]

	// Strip common markdown artifacts and list prefixes.
	sanitized = strings.TrimLeft(sanitized, "-* \t")
	sanitized = strings.TrimPrefix(sanitized, "1. ")
	sanitized = strings.ReplaceAll(sanitized, "**", "")
	sanitized = strings.ReplaceAll(sanitized, "__", "")
	sanitized = strings.Trim(sanitized, "\"'`")
	sanitized = strings.Join(strings.Fields(sanitized), " ")
	if sanitized == "" {
		return ""
	}

	// Clamp very verbose outputs to a concise title-like phrase.
	words := strings.Fields(sanitized)
	if len(words) > 10 {
		sanitized = strings.Join(words[:7], " ")
	}

	// Remove trailing punctuation noise.
	sanitized = strings.TrimRight(sanitized, ".,;:!?-")
	if sanitized == "" {
		return ""
	}

	if len([]rune(sanitized)) > maxConversationTitleChars {
		sanitized = string([]rune(sanitized)[:maxConversationTitleChars])
		sanitized = strings.TrimSpace(sanitized)
	}

	// Avoid replacing with the placeholder-like auto title.
	if strings.EqualFold(sanitized, "new conversation") {
		return ""
	}

	return sanitized
}

// isGeneratedTitleGroundedInSummary checks whether generated title keywords overlap with
// the focused summary keywords.
func isGeneratedTitleGroundedInSummary(title, focusedSummary string) bool {
	titleKeywords := extractGroundingKeywords(title)
	if len(titleKeywords) == 0 {
		return false
	}

	summaryKeywords := extractGroundingKeywords(focusedSummary)
	if len(summaryKeywords) == 0 {
		return true
	}

	for keyword := range titleKeywords {
		if _, found := summaryKeywords[keyword]; found {
			return true
		}
	}

	return false
}

func extractGroundingKeywords(value string) map[string]struct{} {
	clean := strings.ToLower(strings.TrimSpace(value))
	if clean == "" {
		return map[string]struct{}{}
	}

	tokens := strings.FieldsFunc(clean, func(r rune) bool {
		return !unicode.IsLetter(r) && !unicode.IsDigit(r)
	})

	stopwords := map[string]struct{}{
		"a": {}, "all": {}, "an": {}, "and": {}, "are": {}, "as": {}, "at": {}, "be": {},
		"by": {}, "can": {}, "for": {}, "from": {}, "i": {}, "in": {}, "into": {}, "is": {},
		"it": {}, "my": {}, "of": {}, "on": {}, "only": {}, "or": {}, "our": {}, "that": {},
		"the": {}, "then": {}, "this": {}, "to": {}, "up": {}, "use": {}, "using": {},
		"will": {}, "with": {}, "you": {},
		"task": {}, "tasks": {}, "todo": {}, "todos": {}, "plan": {}, "planning": {},
		"create": {}, "created": {}, "ensure": {}, "ensuring": {}, "help": {}, "met": {},
		"need": {}, "needed": {}, "needs": {}, "output": {}, "format": {}, "prefix": {},
		"title": {}, "none": {}, "success": {}, "current": {}, "intent": {}, "user": {},
		"action": {},
	}

	keywords := map[string]struct{}{}
	for _, token := range tokens {
		token = strings.TrimSpace(token)
		if len(token) < 3 {
			continue
		}
		if _, skip := stopwords[token]; skip {
			continue
		}
		keywords[token] = struct{}{}
	}

	return keywords
}
