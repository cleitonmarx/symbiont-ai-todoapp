// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package mocks

import (
	"context"
	"time"

	"github.com/cleitonmarx/symbiont/examples/todoapp/internal/domain"
	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockChatMessageRepository creates a new instance of MockChatMessageRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChatMessageRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockChatMessageRepository {
	mock := &MockChatMessageRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockChatMessageRepository is an autogenerated mock type for the ChatMessageRepository type
type MockChatMessageRepository struct {
	mock.Mock
}

type MockChatMessageRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockChatMessageRepository) EXPECT() *MockChatMessageRepository_Expecter {
	return &MockChatMessageRepository_Expecter{mock: &_m.Mock}
}

// CreateChatMessage provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) CreateChatMessage(ctx context.Context, message domain.ChatMessage) error {
	ret := _mock.Called(ctx, message)

	if len(ret) == 0 {
		panic("no return value specified for CreateChatMessage")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.ChatMessage) error); ok {
		r0 = returnFunc(ctx, message)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatMessageRepository_CreateChatMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateChatMessage'
type MockChatMessageRepository_CreateChatMessage_Call struct {
	*mock.Call
}

// CreateChatMessage is a helper method to define mock.On call
//   - ctx context.Context
//   - message domain.ChatMessage
func (_e *MockChatMessageRepository_Expecter) CreateChatMessage(ctx interface{}, message interface{}) *MockChatMessageRepository_CreateChatMessage_Call {
	return &MockChatMessageRepository_CreateChatMessage_Call{Call: _e.mock.On("CreateChatMessage", ctx, message)}
}

func (_c *MockChatMessageRepository_CreateChatMessage_Call) Run(run func(ctx context.Context, message domain.ChatMessage)) *MockChatMessageRepository_CreateChatMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.ChatMessage
		if args[1] != nil {
			arg1 = args[1].(domain.ChatMessage)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_CreateChatMessage_Call) Return(err error) *MockChatMessageRepository_CreateChatMessage_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatMessageRepository_CreateChatMessage_Call) RunAndReturn(run func(ctx context.Context, message domain.ChatMessage) error) *MockChatMessageRepository_CreateChatMessage_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConversation provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) DeleteConversation(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConversation")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatMessageRepository_DeleteConversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConversation'
type MockChatMessageRepository_DeleteConversation_Call struct {
	*mock.Call
}

// DeleteConversation is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockChatMessageRepository_Expecter) DeleteConversation(ctx interface{}) *MockChatMessageRepository_DeleteConversation_Call {
	return &MockChatMessageRepository_DeleteConversation_Call{Call: _e.mock.On("DeleteConversation", ctx)}
}

func (_c *MockChatMessageRepository_DeleteConversation_Call) Run(run func(ctx context.Context)) *MockChatMessageRepository_DeleteConversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_DeleteConversation_Call) Return(err error) *MockChatMessageRepository_DeleteConversation_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatMessageRepository_DeleteConversation_Call) RunAndReturn(run func(ctx context.Context) error) *MockChatMessageRepository_DeleteConversation_Call {
	_c.Call.Return(run)
	return _c
}

// ListChatMessages provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) ListChatMessages(ctx context.Context, limit int) ([]domain.ChatMessage, bool, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListChatMessages")
	}

	var r0 []domain.ChatMessage
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]domain.ChatMessage, bool, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []domain.ChatMessage); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.ChatMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) bool); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int) error); ok {
		r2 = returnFunc(ctx, limit)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockChatMessageRepository_ListChatMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChatMessages'
type MockChatMessageRepository_ListChatMessages_Call struct {
	*mock.Call
}

// ListChatMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockChatMessageRepository_Expecter) ListChatMessages(ctx interface{}, limit interface{}) *MockChatMessageRepository_ListChatMessages_Call {
	return &MockChatMessageRepository_ListChatMessages_Call{Call: _e.mock.On("ListChatMessages", ctx, limit)}
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) Run(run func(ctx context.Context, limit int)) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) Return(chatMessages []domain.ChatMessage, b bool, err error) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Return(chatMessages, b, err)
	return _c
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]domain.ChatMessage, bool, error)) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTodoEventPublisher creates a new instance of MockTodoEventPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTodoEventPublisher(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTodoEventPublisher {
	mock := &MockTodoEventPublisher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTodoEventPublisher is an autogenerated mock type for the TodoEventPublisher type
type MockTodoEventPublisher struct {
	mock.Mock
}

type MockTodoEventPublisher_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTodoEventPublisher) EXPECT() *MockTodoEventPublisher_Expecter {
	return &MockTodoEventPublisher_Expecter{mock: &_m.Mock}
}

// PublishEvent provides a mock function for the type MockTodoEventPublisher
func (_mock *MockTodoEventPublisher) PublishEvent(ctx context.Context, event domain.OutboxEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for PublishEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.OutboxEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoEventPublisher_PublishEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishEvent'
type MockTodoEventPublisher_PublishEvent_Call struct {
	*mock.Call
}

// PublishEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event domain.OutboxEvent
func (_e *MockTodoEventPublisher_Expecter) PublishEvent(ctx interface{}, event interface{}) *MockTodoEventPublisher_PublishEvent_Call {
	return &MockTodoEventPublisher_PublishEvent_Call{Call: _e.mock.On("PublishEvent", ctx, event)}
}

func (_c *MockTodoEventPublisher_PublishEvent_Call) Run(run func(ctx context.Context, event domain.OutboxEvent)) *MockTodoEventPublisher_PublishEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.OutboxEvent
		if args[1] != nil {
			arg1 = args[1].(domain.OutboxEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoEventPublisher_PublishEvent_Call) Return(err error) *MockTodoEventPublisher_PublishEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoEventPublisher_PublishEvent_Call) RunAndReturn(run func(ctx context.Context, event domain.OutboxEvent) error) *MockTodoEventPublisher_PublishEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLLMClient creates a new instance of MockLLMClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLLMClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLLMClient {
	mock := &MockLLMClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLLMClient is an autogenerated mock type for the LLMClient type
type MockLLMClient struct {
	mock.Mock
}

type MockLLMClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLLMClient) EXPECT() *MockLLMClient_Expecter {
	return &MockLLMClient_Expecter{mock: &_m.Mock}
}

// Chat provides a mock function for the type MockLLMClient
func (_mock *MockLLMClient) Chat(ctx context.Context, req domain.LLMChatRequest) (string, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Chat")
	}

	var r0 string
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.LLMChatRequest) (string, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.LLMChatRequest) string); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Get(0).(string)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, domain.LLMChatRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLLMClient_Chat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chat'
type MockLLMClient_Chat_Call struct {
	*mock.Call
}

// Chat is a helper method to define mock.On call
//   - ctx context.Context
//   - req domain.LLMChatRequest
func (_e *MockLLMClient_Expecter) Chat(ctx interface{}, req interface{}) *MockLLMClient_Chat_Call {
	return &MockLLMClient_Chat_Call{Call: _e.mock.On("Chat", ctx, req)}
}

func (_c *MockLLMClient_Chat_Call) Run(run func(ctx context.Context, req domain.LLMChatRequest)) *MockLLMClient_Chat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.LLMChatRequest
		if args[1] != nil {
			arg1 = args[1].(domain.LLMChatRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockLLMClient_Chat_Call) Return(s string, err error) *MockLLMClient_Chat_Call {
	_c.Call.Return(s, err)
	return _c
}

func (_c *MockLLMClient_Chat_Call) RunAndReturn(run func(ctx context.Context, req domain.LLMChatRequest) (string, error)) *MockLLMClient_Chat_Call {
	_c.Call.Return(run)
	return _c
}

// ChatStream provides a mock function for the type MockLLMClient
func (_mock *MockLLMClient) ChatStream(ctx context.Context, req domain.LLMChatRequest, onEvent domain.LLMStreamEventCallback) error {
	ret := _mock.Called(ctx, req, onEvent)

	if len(ret) == 0 {
		panic("no return value specified for ChatStream")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.LLMChatRequest, domain.LLMStreamEventCallback) error); ok {
		r0 = returnFunc(ctx, req, onEvent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLLMClient_ChatStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChatStream'
type MockLLMClient_ChatStream_Call struct {
	*mock.Call
}

// ChatStream is a helper method to define mock.On call
//   - ctx context.Context
//   - req domain.LLMChatRequest
//   - onEvent domain.LLMStreamEventCallback
func (_e *MockLLMClient_Expecter) ChatStream(ctx interface{}, req interface{}, onEvent interface{}) *MockLLMClient_ChatStream_Call {
	return &MockLLMClient_ChatStream_Call{Call: _e.mock.On("ChatStream", ctx, req, onEvent)}
}

func (_c *MockLLMClient_ChatStream_Call) Run(run func(ctx context.Context, req domain.LLMChatRequest, onEvent domain.LLMStreamEventCallback)) *MockLLMClient_ChatStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.LLMChatRequest
		if args[1] != nil {
			arg1 = args[1].(domain.LLMChatRequest)
		}
		var arg2 domain.LLMStreamEventCallback
		if args[2] != nil {
			arg2 = args[2].(domain.LLMStreamEventCallback)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLLMClient_ChatStream_Call) Return(err error) *MockLLMClient_ChatStream_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLLMClient_ChatStream_Call) RunAndReturn(run func(ctx context.Context, req domain.LLMChatRequest, onEvent domain.LLMStreamEventCallback) error) *MockLLMClient_ChatStream_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOutboxRepository creates a new instance of MockOutboxRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOutboxRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOutboxRepository {
	mock := &MockOutboxRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOutboxRepository is an autogenerated mock type for the OutboxRepository type
type MockOutboxRepository struct {
	mock.Mock
}

type MockOutboxRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOutboxRepository) EXPECT() *MockOutboxRepository_Expecter {
	return &MockOutboxRepository_Expecter{mock: &_m.Mock}
}

// DeleteEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) DeleteEvent(ctx context.Context, eventID uuid.UUID) error {
	ret := _mock.Called(ctx, eventID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, eventID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_DeleteEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEvent'
type MockOutboxRepository_DeleteEvent_Call struct {
	*mock.Call
}

// DeleteEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID uuid.UUID
func (_e *MockOutboxRepository_Expecter) DeleteEvent(ctx interface{}, eventID interface{}) *MockOutboxRepository_DeleteEvent_Call {
	return &MockOutboxRepository_DeleteEvent_Call{Call: _e.mock.On("DeleteEvent", ctx, eventID)}
}

func (_c *MockOutboxRepository_DeleteEvent_Call) Run(run func(ctx context.Context, eventID uuid.UUID)) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_DeleteEvent_Call) Return(err error) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_DeleteEvent_Call) RunAndReturn(run func(ctx context.Context, eventID uuid.UUID) error) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Return(run)
	return _c
}

// FetchPendingEvents provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) FetchPendingEvents(ctx context.Context, limit int) ([]domain.OutboxEvent, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for FetchPendingEvents")
	}

	var r0 []domain.OutboxEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]domain.OutboxEvent, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []domain.OutboxEvent); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.OutboxEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOutboxRepository_FetchPendingEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchPendingEvents'
type MockOutboxRepository_FetchPendingEvents_Call struct {
	*mock.Call
}

// FetchPendingEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockOutboxRepository_Expecter) FetchPendingEvents(ctx interface{}, limit interface{}) *MockOutboxRepository_FetchPendingEvents_Call {
	return &MockOutboxRepository_FetchPendingEvents_Call{Call: _e.mock.On("FetchPendingEvents", ctx, limit)}
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) Run(run func(ctx context.Context, limit int)) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) Return(outboxEvents []domain.OutboxEvent, err error) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Return(outboxEvents, err)
	return _c
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]domain.OutboxEvent, error)) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Return(run)
	return _c
}

// RecordEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) RecordEvent(ctx context.Context, event domain.TodoEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for RecordEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.TodoEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_RecordEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'RecordEvent'
type MockOutboxRepository_RecordEvent_Call struct {
	*mock.Call
}

// RecordEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event domain.TodoEvent
func (_e *MockOutboxRepository_Expecter) RecordEvent(ctx interface{}, event interface{}) *MockOutboxRepository_RecordEvent_Call {
	return &MockOutboxRepository_RecordEvent_Call{Call: _e.mock.On("RecordEvent", ctx, event)}
}

func (_c *MockOutboxRepository_RecordEvent_Call) Run(run func(ctx context.Context, event domain.TodoEvent)) *MockOutboxRepository_RecordEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.TodoEvent
		if args[1] != nil {
			arg1 = args[1].(domain.TodoEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_RecordEvent_Call) Return(err error) *MockOutboxRepository_RecordEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_RecordEvent_Call) RunAndReturn(run func(ctx context.Context, event domain.TodoEvent) error) *MockOutboxRepository_RecordEvent_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) UpdateEvent(ctx context.Context, eventID uuid.UUID, status string, retryCount int, lastError string) error {
	ret := _mock.Called(ctx, eventID, status, retryCount, lastError)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, int, string) error); ok {
		r0 = returnFunc(ctx, eventID, status, retryCount, lastError)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_UpdateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEvent'
type MockOutboxRepository_UpdateEvent_Call struct {
	*mock.Call
}

// UpdateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID uuid.UUID
//   - status string
//   - retryCount int
//   - lastError string
func (_e *MockOutboxRepository_Expecter) UpdateEvent(ctx interface{}, eventID interface{}, status interface{}, retryCount interface{}, lastError interface{}) *MockOutboxRepository_UpdateEvent_Call {
	return &MockOutboxRepository_UpdateEvent_Call{Call: _e.mock.On("UpdateEvent", ctx, eventID, status, retryCount, lastError)}
}

func (_c *MockOutboxRepository_UpdateEvent_Call) Run(run func(ctx context.Context, eventID uuid.UUID, status string, retryCount int, lastError string)) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_UpdateEvent_Call) Return(err error) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_UpdateEvent_Call) RunAndReturn(run func(ctx context.Context, eventID uuid.UUID, status string, retryCount int, lastError string) error) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBoardSummaryRepository creates a new instance of MockBoardSummaryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBoardSummaryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBoardSummaryRepository {
	mock := &MockBoardSummaryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBoardSummaryRepository is an autogenerated mock type for the BoardSummaryRepository type
type MockBoardSummaryRepository struct {
	mock.Mock
}

type MockBoardSummaryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBoardSummaryRepository) EXPECT() *MockBoardSummaryRepository_Expecter {
	return &MockBoardSummaryRepository_Expecter{mock: &_m.Mock}
}

// GetLatestSummary provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) GetLatestSummary(ctx context.Context) (domain.BoardSummary, bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestSummary")
	}

	var r0 domain.BoardSummary
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (domain.BoardSummary, bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) domain.BoardSummary); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(domain.BoardSummary)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = returnFunc(ctx)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockBoardSummaryRepository_GetLatestSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestSummary'
type MockBoardSummaryRepository_GetLatestSummary_Call struct {
	*mock.Call
}

// GetLatestSummary is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBoardSummaryRepository_Expecter) GetLatestSummary(ctx interface{}) *MockBoardSummaryRepository_GetLatestSummary_Call {
	return &MockBoardSummaryRepository_GetLatestSummary_Call{Call: _e.mock.On("GetLatestSummary", ctx)}
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) Run(run func(ctx context.Context)) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) Return(boardSummary domain.BoardSummary, b bool, err error) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Return(boardSummary, b, err)
	return _c
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) RunAndReturn(run func(ctx context.Context) (domain.BoardSummary, bool, error)) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Return(run)
	return _c
}

// StoreSummary provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) StoreSummary(ctx context.Context, summary domain.BoardSummary) error {
	ret := _mock.Called(ctx, summary)

	if len(ret) == 0 {
		panic("no return value specified for StoreSummary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.BoardSummary) error); ok {
		r0 = returnFunc(ctx, summary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBoardSummaryRepository_StoreSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreSummary'
type MockBoardSummaryRepository_StoreSummary_Call struct {
	*mock.Call
}

// StoreSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - summary domain.BoardSummary
func (_e *MockBoardSummaryRepository_Expecter) StoreSummary(ctx interface{}, summary interface{}) *MockBoardSummaryRepository_StoreSummary_Call {
	return &MockBoardSummaryRepository_StoreSummary_Call{Call: _e.mock.On("StoreSummary", ctx, summary)}
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) Run(run func(ctx context.Context, summary domain.BoardSummary)) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.BoardSummary
		if args[1] != nil {
			arg1 = args[1].(domain.BoardSummary)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) Return(err error) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) RunAndReturn(run func(ctx context.Context, summary domain.BoardSummary) error) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCurrentTimeProvider creates a new instance of MockCurrentTimeProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCurrentTimeProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCurrentTimeProvider {
	mock := &MockCurrentTimeProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCurrentTimeProvider is an autogenerated mock type for the CurrentTimeProvider type
type MockCurrentTimeProvider struct {
	mock.Mock
}

type MockCurrentTimeProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCurrentTimeProvider) EXPECT() *MockCurrentTimeProvider_Expecter {
	return &MockCurrentTimeProvider_Expecter{mock: &_m.Mock}
}

// Now provides a mock function for the type MockCurrentTimeProvider
func (_mock *MockCurrentTimeProvider) Now() time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Now")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func() time.Time); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// MockCurrentTimeProvider_Now_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Now'
type MockCurrentTimeProvider_Now_Call struct {
	*mock.Call
}

// Now is a helper method to define mock.On call
func (_e *MockCurrentTimeProvider_Expecter) Now() *MockCurrentTimeProvider_Now_Call {
	return &MockCurrentTimeProvider_Now_Call{Call: _e.mock.On("Now")}
}

func (_c *MockCurrentTimeProvider_Now_Call) Run(run func()) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCurrentTimeProvider_Now_Call) Return(time1 time.Time) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockCurrentTimeProvider_Now_Call) RunAndReturn(run func() time.Time) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTodoRepository creates a new instance of MockTodoRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTodoRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTodoRepository {
	mock := &MockTodoRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTodoRepository is an autogenerated mock type for the TodoRepository type
type MockTodoRepository struct {
	mock.Mock
}

type MockTodoRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTodoRepository) EXPECT() *MockTodoRepository_Expecter {
	return &MockTodoRepository_Expecter{mock: &_m.Mock}
}

// CreateTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) CreateTodo(ctx context.Context, todo domain.Todo) error {
	ret := _mock.Called(ctx, todo)

	if len(ret) == 0 {
		panic("no return value specified for CreateTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Todo) error); ok {
		r0 = returnFunc(ctx, todo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_CreateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTodo'
type MockTodoRepository_CreateTodo_Call struct {
	*mock.Call
}

// CreateTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - todo domain.Todo
func (_e *MockTodoRepository_Expecter) CreateTodo(ctx interface{}, todo interface{}) *MockTodoRepository_CreateTodo_Call {
	return &MockTodoRepository_CreateTodo_Call{Call: _e.mock.On("CreateTodo", ctx, todo)}
}

func (_c *MockTodoRepository_CreateTodo_Call) Run(run func(ctx context.Context, todo domain.Todo)) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.Todo
		if args[1] != nil {
			arg1 = args[1].(domain.Todo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_CreateTodo_Call) Return(err error) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_CreateTodo_Call) RunAndReturn(run func(ctx context.Context, todo domain.Todo) error) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) DeleteTodo(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_DeleteTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTodo'
type MockTodoRepository_DeleteTodo_Call struct {
	*mock.Call
}

// DeleteTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockTodoRepository_Expecter) DeleteTodo(ctx interface{}, id interface{}) *MockTodoRepository_DeleteTodo_Call {
	return &MockTodoRepository_DeleteTodo_Call{Call: _e.mock.On("DeleteTodo", ctx, id)}
}

func (_c *MockTodoRepository_DeleteTodo_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_DeleteTodo_Call) Return(err error) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_DeleteTodo_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) GetTodo(ctx context.Context, id uuid.UUID) (domain.Todo, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTodo")
	}

	var r0 domain.Todo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (domain.Todo, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) domain.Todo); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(domain.Todo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) error); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockTodoRepository_GetTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTodo'
type MockTodoRepository_GetTodo_Call struct {
	*mock.Call
}

// GetTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockTodoRepository_Expecter) GetTodo(ctx interface{}, id interface{}) *MockTodoRepository_GetTodo_Call {
	return &MockTodoRepository_GetTodo_Call{Call: _e.mock.On("GetTodo", ctx, id)}
}

func (_c *MockTodoRepository_GetTodo_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockTodoRepository_GetTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_GetTodo_Call) Return(todo domain.Todo, err error) *MockTodoRepository_GetTodo_Call {
	_c.Call.Return(todo, err)
	return _c
}

func (_c *MockTodoRepository_GetTodo_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (domain.Todo, error)) *MockTodoRepository_GetTodo_Call {
	_c.Call.Return(run)
	return _c
}

// ListTodos provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) ListTodos(ctx context.Context, page int, pageSize int, opts ...domain.ListTodoOptions) ([]domain.Todo, bool, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, page, pageSize, opts)
	} else {
		tmpRet = _mock.Called(ctx, page, pageSize)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListTodos")
	}

	var r0 []domain.Todo
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...domain.ListTodoOptions) ([]domain.Todo, bool, error)); ok {
		return returnFunc(ctx, page, pageSize, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...domain.ListTodoOptions) []domain.Todo); ok {
		r0 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]domain.Todo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int, ...domain.ListTodoOptions) bool); ok {
		r1 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int, ...domain.ListTodoOptions) error); ok {
		r2 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTodoRepository_ListTodos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTodos'
type MockTodoRepository_ListTodos_Call struct {
	*mock.Call
}

// ListTodos is a helper method to define mock.On call
//   - ctx context.Context
//   - page int
//   - pageSize int
//   - opts ...domain.ListTodoOptions
func (_e *MockTodoRepository_Expecter) ListTodos(ctx interface{}, page interface{}, pageSize interface{}, opts ...interface{}) *MockTodoRepository_ListTodos_Call {
	return &MockTodoRepository_ListTodos_Call{Call: _e.mock.On("ListTodos",
		append([]interface{}{ctx, page, pageSize}, opts...)...)}
}

func (_c *MockTodoRepository_ListTodos_Call) Run(run func(ctx context.Context, page int, pageSize int, opts ...domain.ListTodoOptions)) *MockTodoRepository_ListTodos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 []domain.ListTodoOptions
		var variadicArgs []domain.ListTodoOptions
		if len(args) > 3 {
			variadicArgs = args[3].([]domain.ListTodoOptions)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockTodoRepository_ListTodos_Call) Return(todos []domain.Todo, b bool, err error) *MockTodoRepository_ListTodos_Call {
	_c.Call.Return(todos, b, err)
	return _c
}

func (_c *MockTodoRepository_ListTodos_Call) RunAndReturn(run func(ctx context.Context, page int, pageSize int, opts ...domain.ListTodoOptions) ([]domain.Todo, bool, error)) *MockTodoRepository_ListTodos_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) UpdateTodo(ctx context.Context, todo domain.Todo) error {
	ret := _mock.Called(ctx, todo)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, domain.Todo) error); ok {
		r0 = returnFunc(ctx, todo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_UpdateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTodo'
type MockTodoRepository_UpdateTodo_Call struct {
	*mock.Call
}

// UpdateTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - todo domain.Todo
func (_e *MockTodoRepository_Expecter) UpdateTodo(ctx interface{}, todo interface{}) *MockTodoRepository_UpdateTodo_Call {
	return &MockTodoRepository_UpdateTodo_Call{Call: _e.mock.On("UpdateTodo", ctx, todo)}
}

func (_c *MockTodoRepository_UpdateTodo_Call) Run(run func(ctx context.Context, todo domain.Todo)) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 domain.Todo
		if args[1] != nil {
			arg1 = args[1].(domain.Todo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_UpdateTodo_Call) Return(err error) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_UpdateTodo_Call) RunAndReturn(run func(ctx context.Context, todo domain.Todo) error) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUnitOfWork creates a new instance of MockUnitOfWork. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUnitOfWork(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUnitOfWork {
	mock := &MockUnitOfWork{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUnitOfWork is an autogenerated mock type for the UnitOfWork type
type MockUnitOfWork struct {
	mock.Mock
}

type MockUnitOfWork_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUnitOfWork) EXPECT() *MockUnitOfWork_Expecter {
	return &MockUnitOfWork_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Execute(ctx context.Context, fn func(uow domain.UnitOfWork) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(uow domain.UnitOfWork) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUnitOfWork_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUnitOfWork_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(uow domain.UnitOfWork) error
func (_e *MockUnitOfWork_Expecter) Execute(ctx interface{}, fn interface{}) *MockUnitOfWork_Execute_Call {
	return &MockUnitOfWork_Execute_Call{Call: _e.mock.On("Execute", ctx, fn)}
}

func (_c *MockUnitOfWork_Execute_Call) Run(run func(ctx context.Context, fn func(uow domain.UnitOfWork) error)) *MockUnitOfWork_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(uow domain.UnitOfWork) error
		if args[1] != nil {
			arg1 = args[1].(func(uow domain.UnitOfWork) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUnitOfWork_Execute_Call) Return(err error) *MockUnitOfWork_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUnitOfWork_Execute_Call) RunAndReturn(run func(ctx context.Context, fn func(uow domain.UnitOfWork) error) error) *MockUnitOfWork_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// Outbox provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Outbox() domain.OutboxRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Outbox")
	}

	var r0 domain.OutboxRepository
	if returnFunc, ok := ret.Get(0).(func() domain.OutboxRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(domain.OutboxRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Outbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Outbox'
type MockUnitOfWork_Outbox_Call struct {
	*mock.Call
}

// Outbox is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Outbox() *MockUnitOfWork_Outbox_Call {
	return &MockUnitOfWork_Outbox_Call{Call: _e.mock.On("Outbox")}
}

func (_c *MockUnitOfWork_Outbox_Call) Run(run func()) *MockUnitOfWork_Outbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Outbox_Call) Return(outboxRepository domain.OutboxRepository) *MockUnitOfWork_Outbox_Call {
	_c.Call.Return(outboxRepository)
	return _c
}

func (_c *MockUnitOfWork_Outbox_Call) RunAndReturn(run func() domain.OutboxRepository) *MockUnitOfWork_Outbox_Call {
	_c.Call.Return(run)
	return _c
}

// Todo provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Todo() domain.TodoRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Todo")
	}

	var r0 domain.TodoRepository
	if returnFunc, ok := ret.Get(0).(func() domain.TodoRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(domain.TodoRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Todo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Todo'
type MockUnitOfWork_Todo_Call struct {
	*mock.Call
}

// Todo is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Todo() *MockUnitOfWork_Todo_Call {
	return &MockUnitOfWork_Todo_Call{Call: _e.mock.On("Todo")}
}

func (_c *MockUnitOfWork_Todo_Call) Run(run func()) *MockUnitOfWork_Todo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Todo_Call) Return(todoRepository domain.TodoRepository) *MockUnitOfWork_Todo_Call {
	_c.Call.Return(todoRepository)
	return _c
}

func (_c *MockUnitOfWork_Todo_Call) RunAndReturn(run func() domain.TodoRepository) *MockUnitOfWork_Todo_Call {
	_c.Call.Return(run)
	return _c
}
