// Code generated by mockery; DO NOT EDIT.
// github.com/vektra/mockery
// template: testify

package domain

import (
	"context"
	"time"

	"github.com/google/uuid"
	mock "github.com/stretchr/testify/mock"
)

// NewMockChatMessageRepository creates a new instance of MockChatMessageRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockChatMessageRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockChatMessageRepository {
	mock := &MockChatMessageRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockChatMessageRepository is an autogenerated mock type for the ChatMessageRepository type
type MockChatMessageRepository struct {
	mock.Mock
}

type MockChatMessageRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockChatMessageRepository) EXPECT() *MockChatMessageRepository_Expecter {
	return &MockChatMessageRepository_Expecter{mock: &_m.Mock}
}

// CreateChatMessages provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) CreateChatMessages(ctx context.Context, messages []ChatMessage) error {
	ret := _mock.Called(ctx, messages)

	if len(ret) == 0 {
		panic("no return value specified for CreateChatMessages")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, []ChatMessage) error); ok {
		r0 = returnFunc(ctx, messages)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatMessageRepository_CreateChatMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateChatMessages'
type MockChatMessageRepository_CreateChatMessages_Call struct {
	*mock.Call
}

// CreateChatMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - messages []ChatMessage
func (_e *MockChatMessageRepository_Expecter) CreateChatMessages(ctx interface{}, messages interface{}) *MockChatMessageRepository_CreateChatMessages_Call {
	return &MockChatMessageRepository_CreateChatMessages_Call{Call: _e.mock.On("CreateChatMessages", ctx, messages)}
}

func (_c *MockChatMessageRepository_CreateChatMessages_Call) Run(run func(ctx context.Context, messages []ChatMessage)) *MockChatMessageRepository_CreateChatMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 []ChatMessage
		if args[1] != nil {
			arg1 = args[1].([]ChatMessage)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_CreateChatMessages_Call) Return(err error) *MockChatMessageRepository_CreateChatMessages_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatMessageRepository_CreateChatMessages_Call) RunAndReturn(run func(ctx context.Context, messages []ChatMessage) error) *MockChatMessageRepository_CreateChatMessages_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteConversation provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) DeleteConversation(ctx context.Context) error {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for DeleteConversation")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) error); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockChatMessageRepository_DeleteConversation_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteConversation'
type MockChatMessageRepository_DeleteConversation_Call struct {
	*mock.Call
}

// DeleteConversation is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockChatMessageRepository_Expecter) DeleteConversation(ctx interface{}) *MockChatMessageRepository_DeleteConversation_Call {
	return &MockChatMessageRepository_DeleteConversation_Call{Call: _e.mock.On("DeleteConversation", ctx)}
}

func (_c *MockChatMessageRepository_DeleteConversation_Call) Run(run func(ctx context.Context)) *MockChatMessageRepository_DeleteConversation_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_DeleteConversation_Call) Return(err error) *MockChatMessageRepository_DeleteConversation_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockChatMessageRepository_DeleteConversation_Call) RunAndReturn(run func(ctx context.Context) error) *MockChatMessageRepository_DeleteConversation_Call {
	_c.Call.Return(run)
	return _c
}

// ListChatMessages provides a mock function for the type MockChatMessageRepository
func (_mock *MockChatMessageRepository) ListChatMessages(ctx context.Context, limit int) ([]ChatMessage, bool, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for ListChatMessages")
	}

	var r0 []ChatMessage
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]ChatMessage, bool, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []ChatMessage); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]ChatMessage)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) bool); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int) error); ok {
		r2 = returnFunc(ctx, limit)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockChatMessageRepository_ListChatMessages_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListChatMessages'
type MockChatMessageRepository_ListChatMessages_Call struct {
	*mock.Call
}

// ListChatMessages is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockChatMessageRepository_Expecter) ListChatMessages(ctx interface{}, limit interface{}) *MockChatMessageRepository_ListChatMessages_Call {
	return &MockChatMessageRepository_ListChatMessages_Call{Call: _e.mock.On("ListChatMessages", ctx, limit)}
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) Run(run func(ctx context.Context, limit int)) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) Return(chatMessages []ChatMessage, b bool, err error) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Return(chatMessages, b, err)
	return _c
}

func (_c *MockChatMessageRepository_ListChatMessages_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]ChatMessage, bool, error)) *MockChatMessageRepository_ListChatMessages_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTodoEventPublisher creates a new instance of MockTodoEventPublisher. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTodoEventPublisher(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTodoEventPublisher {
	mock := &MockTodoEventPublisher{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTodoEventPublisher is an autogenerated mock type for the TodoEventPublisher type
type MockTodoEventPublisher struct {
	mock.Mock
}

type MockTodoEventPublisher_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTodoEventPublisher) EXPECT() *MockTodoEventPublisher_Expecter {
	return &MockTodoEventPublisher_Expecter{mock: &_m.Mock}
}

// PublishEvent provides a mock function for the type MockTodoEventPublisher
func (_mock *MockTodoEventPublisher) PublishEvent(ctx context.Context, event OutboxEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for PublishEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, OutboxEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoEventPublisher_PublishEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'PublishEvent'
type MockTodoEventPublisher_PublishEvent_Call struct {
	*mock.Call
}

// PublishEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event OutboxEvent
func (_e *MockTodoEventPublisher_Expecter) PublishEvent(ctx interface{}, event interface{}) *MockTodoEventPublisher_PublishEvent_Call {
	return &MockTodoEventPublisher_PublishEvent_Call{Call: _e.mock.On("PublishEvent", ctx, event)}
}

func (_c *MockTodoEventPublisher_PublishEvent_Call) Run(run func(ctx context.Context, event OutboxEvent)) *MockTodoEventPublisher_PublishEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 OutboxEvent
		if args[1] != nil {
			arg1 = args[1].(OutboxEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoEventPublisher_PublishEvent_Call) Return(err error) *MockTodoEventPublisher_PublishEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoEventPublisher_PublishEvent_Call) RunAndReturn(run func(ctx context.Context, event OutboxEvent) error) *MockTodoEventPublisher_PublishEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLLMTool creates a new instance of MockLLMTool. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLLMTool(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLLMTool {
	mock := &MockLLMTool{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLLMTool is an autogenerated mock type for the LLMTool type
type MockLLMTool struct {
	mock.Mock
}

type MockLLMTool_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLLMTool) EXPECT() *MockLLMTool_Expecter {
	return &MockLLMTool_Expecter{mock: &_m.Mock}
}

// Call provides a mock function for the type MockLLMTool
func (_mock *MockLLMTool) Call(context1 context.Context, lLMStreamEventToolCall LLMStreamEventToolCall, lLMChatMessages []LLMChatMessage) LLMChatMessage {
	ret := _mock.Called(context1, lLMStreamEventToolCall, lLMChatMessages)

	if len(ret) == 0 {
		panic("no return value specified for Call")
	}

	var r0 LLMChatMessage
	if returnFunc, ok := ret.Get(0).(func(context.Context, LLMStreamEventToolCall, []LLMChatMessage) LLMChatMessage); ok {
		r0 = returnFunc(context1, lLMStreamEventToolCall, lLMChatMessages)
	} else {
		r0 = ret.Get(0).(LLMChatMessage)
	}
	return r0
}

// MockLLMTool_Call_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Call'
type MockLLMTool_Call_Call struct {
	*mock.Call
}

// Call is a helper method to define mock.On call
//   - context1 context.Context
//   - lLMStreamEventToolCall LLMStreamEventToolCall
//   - lLMChatMessages []LLMChatMessage
func (_e *MockLLMTool_Expecter) Call(context1 interface{}, lLMStreamEventToolCall interface{}, lLMChatMessages interface{}) *MockLLMTool_Call_Call {
	return &MockLLMTool_Call_Call{Call: _e.mock.On("Call", context1, lLMStreamEventToolCall, lLMChatMessages)}
}

func (_c *MockLLMTool_Call_Call) Run(run func(context1 context.Context, lLMStreamEventToolCall LLMStreamEventToolCall, lLMChatMessages []LLMChatMessage)) *MockLLMTool_Call_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 LLMStreamEventToolCall
		if args[1] != nil {
			arg1 = args[1].(LLMStreamEventToolCall)
		}
		var arg2 []LLMChatMessage
		if args[2] != nil {
			arg2 = args[2].([]LLMChatMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLLMTool_Call_Call) Return(lLMChatMessage LLMChatMessage) *MockLLMTool_Call_Call {
	_c.Call.Return(lLMChatMessage)
	return _c
}

func (_c *MockLLMTool_Call_Call) RunAndReturn(run func(context1 context.Context, lLMStreamEventToolCall LLMStreamEventToolCall, lLMChatMessages []LLMChatMessage) LLMChatMessage) *MockLLMTool_Call_Call {
	_c.Call.Return(run)
	return _c
}

// Definition provides a mock function for the type MockLLMTool
func (_mock *MockLLMTool) Definition() LLMToolDefinition {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Definition")
	}

	var r0 LLMToolDefinition
	if returnFunc, ok := ret.Get(0).(func() LLMToolDefinition); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(LLMToolDefinition)
	}
	return r0
}

// MockLLMTool_Definition_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Definition'
type MockLLMTool_Definition_Call struct {
	*mock.Call
}

// Definition is a helper method to define mock.On call
func (_e *MockLLMTool_Expecter) Definition() *MockLLMTool_Definition_Call {
	return &MockLLMTool_Definition_Call{Call: _e.mock.On("Definition")}
}

func (_c *MockLLMTool_Definition_Call) Run(run func()) *MockLLMTool_Definition_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLLMTool_Definition_Call) Return(lLMToolDefinition LLMToolDefinition) *MockLLMTool_Definition_Call {
	_c.Call.Return(lLMToolDefinition)
	return _c
}

func (_c *MockLLMTool_Definition_Call) RunAndReturn(run func() LLMToolDefinition) *MockLLMTool_Definition_Call {
	_c.Call.Return(run)
	return _c
}

// StatusMessage provides a mock function for the type MockLLMTool
func (_mock *MockLLMTool) StatusMessage() string {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for StatusMessage")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func() string); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockLLMTool_StatusMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusMessage'
type MockLLMTool_StatusMessage_Call struct {
	*mock.Call
}

// StatusMessage is a helper method to define mock.On call
func (_e *MockLLMTool_Expecter) StatusMessage() *MockLLMTool_StatusMessage_Call {
	return &MockLLMTool_StatusMessage_Call{Call: _e.mock.On("StatusMessage")}
}

func (_c *MockLLMTool_StatusMessage_Call) Run(run func()) *MockLLMTool_StatusMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLLMTool_StatusMessage_Call) Return(s string) *MockLLMTool_StatusMessage_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockLLMTool_StatusMessage_Call) RunAndReturn(run func() string) *MockLLMTool_StatusMessage_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLLMToolRegistry creates a new instance of MockLLMToolRegistry. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLLMToolRegistry(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLLMToolRegistry {
	mock := &MockLLMToolRegistry{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLLMToolRegistry is an autogenerated mock type for the LLMToolRegistry type
type MockLLMToolRegistry struct {
	mock.Mock
}

type MockLLMToolRegistry_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLLMToolRegistry) EXPECT() *MockLLMToolRegistry_Expecter {
	return &MockLLMToolRegistry_Expecter{mock: &_m.Mock}
}

// Call provides a mock function for the type MockLLMToolRegistry
func (_mock *MockLLMToolRegistry) Call(context1 context.Context, lLMStreamEventToolCall LLMStreamEventToolCall, lLMChatMessages []LLMChatMessage) LLMChatMessage {
	ret := _mock.Called(context1, lLMStreamEventToolCall, lLMChatMessages)

	if len(ret) == 0 {
		panic("no return value specified for Call")
	}

	var r0 LLMChatMessage
	if returnFunc, ok := ret.Get(0).(func(context.Context, LLMStreamEventToolCall, []LLMChatMessage) LLMChatMessage); ok {
		r0 = returnFunc(context1, lLMStreamEventToolCall, lLMChatMessages)
	} else {
		r0 = ret.Get(0).(LLMChatMessage)
	}
	return r0
}

// MockLLMToolRegistry_Call_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Call'
type MockLLMToolRegistry_Call_Call struct {
	*mock.Call
}

// Call is a helper method to define mock.On call
//   - context1 context.Context
//   - lLMStreamEventToolCall LLMStreamEventToolCall
//   - lLMChatMessages []LLMChatMessage
func (_e *MockLLMToolRegistry_Expecter) Call(context1 interface{}, lLMStreamEventToolCall interface{}, lLMChatMessages interface{}) *MockLLMToolRegistry_Call_Call {
	return &MockLLMToolRegistry_Call_Call{Call: _e.mock.On("Call", context1, lLMStreamEventToolCall, lLMChatMessages)}
}

func (_c *MockLLMToolRegistry_Call_Call) Run(run func(context1 context.Context, lLMStreamEventToolCall LLMStreamEventToolCall, lLMChatMessages []LLMChatMessage)) *MockLLMToolRegistry_Call_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 LLMStreamEventToolCall
		if args[1] != nil {
			arg1 = args[1].(LLMStreamEventToolCall)
		}
		var arg2 []LLMChatMessage
		if args[2] != nil {
			arg2 = args[2].([]LLMChatMessage)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLLMToolRegistry_Call_Call) Return(lLMChatMessage LLMChatMessage) *MockLLMToolRegistry_Call_Call {
	_c.Call.Return(lLMChatMessage)
	return _c
}

func (_c *MockLLMToolRegistry_Call_Call) RunAndReturn(run func(context1 context.Context, lLMStreamEventToolCall LLMStreamEventToolCall, lLMChatMessages []LLMChatMessage) LLMChatMessage) *MockLLMToolRegistry_Call_Call {
	_c.Call.Return(run)
	return _c
}

// List provides a mock function for the type MockLLMToolRegistry
func (_mock *MockLLMToolRegistry) List() []LLMToolDefinition {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for List")
	}

	var r0 []LLMToolDefinition
	if returnFunc, ok := ret.Get(0).(func() []LLMToolDefinition); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]LLMToolDefinition)
		}
	}
	return r0
}

// MockLLMToolRegistry_List_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'List'
type MockLLMToolRegistry_List_Call struct {
	*mock.Call
}

// List is a helper method to define mock.On call
func (_e *MockLLMToolRegistry_Expecter) List() *MockLLMToolRegistry_List_Call {
	return &MockLLMToolRegistry_List_Call{Call: _e.mock.On("List")}
}

func (_c *MockLLMToolRegistry_List_Call) Run(run func()) *MockLLMToolRegistry_List_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockLLMToolRegistry_List_Call) Return(lLMToolDefinitions []LLMToolDefinition) *MockLLMToolRegistry_List_Call {
	_c.Call.Return(lLMToolDefinitions)
	return _c
}

func (_c *MockLLMToolRegistry_List_Call) RunAndReturn(run func() []LLMToolDefinition) *MockLLMToolRegistry_List_Call {
	_c.Call.Return(run)
	return _c
}

// StatusMessage provides a mock function for the type MockLLMToolRegistry
func (_mock *MockLLMToolRegistry) StatusMessage(toolName string) string {
	ret := _mock.Called(toolName)

	if len(ret) == 0 {
		panic("no return value specified for StatusMessage")
	}

	var r0 string
	if returnFunc, ok := ret.Get(0).(func(string) string); ok {
		r0 = returnFunc(toolName)
	} else {
		r0 = ret.Get(0).(string)
	}
	return r0
}

// MockLLMToolRegistry_StatusMessage_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StatusMessage'
type MockLLMToolRegistry_StatusMessage_Call struct {
	*mock.Call
}

// StatusMessage is a helper method to define mock.On call
//   - toolName string
func (_e *MockLLMToolRegistry_Expecter) StatusMessage(toolName interface{}) *MockLLMToolRegistry_StatusMessage_Call {
	return &MockLLMToolRegistry_StatusMessage_Call{Call: _e.mock.On("StatusMessage", toolName)}
}

func (_c *MockLLMToolRegistry_StatusMessage_Call) Run(run func(toolName string)) *MockLLMToolRegistry_StatusMessage_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 string
		if args[0] != nil {
			arg0 = args[0].(string)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockLLMToolRegistry_StatusMessage_Call) Return(s string) *MockLLMToolRegistry_StatusMessage_Call {
	_c.Call.Return(s)
	return _c
}

func (_c *MockLLMToolRegistry_StatusMessage_Call) RunAndReturn(run func(toolName string) string) *MockLLMToolRegistry_StatusMessage_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockLLMClient creates a new instance of MockLLMClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockLLMClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockLLMClient {
	mock := &MockLLMClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockLLMClient is an autogenerated mock type for the LLMClient type
type MockLLMClient struct {
	mock.Mock
}

type MockLLMClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockLLMClient) EXPECT() *MockLLMClient_Expecter {
	return &MockLLMClient_Expecter{mock: &_m.Mock}
}

// AvailableModels provides a mock function for the type MockLLMClient
func (_mock *MockLLMClient) AvailableModels(ctx context.Context) ([]LLMModelInfo, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for AvailableModels")
	}

	var r0 []LLMModelInfo
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) ([]LLMModelInfo, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) []LLMModelInfo); ok {
		r0 = returnFunc(ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]LLMModelInfo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLLMClient_AvailableModels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'AvailableModels'
type MockLLMClient_AvailableModels_Call struct {
	*mock.Call
}

// AvailableModels is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockLLMClient_Expecter) AvailableModels(ctx interface{}) *MockLLMClient_AvailableModels_Call {
	return &MockLLMClient_AvailableModels_Call{Call: _e.mock.On("AvailableModels", ctx)}
}

func (_c *MockLLMClient_AvailableModels_Call) Run(run func(ctx context.Context)) *MockLLMClient_AvailableModels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockLLMClient_AvailableModels_Call) Return(lLMModelInfos []LLMModelInfo, err error) *MockLLMClient_AvailableModels_Call {
	_c.Call.Return(lLMModelInfos, err)
	return _c
}

func (_c *MockLLMClient_AvailableModels_Call) RunAndReturn(run func(ctx context.Context) ([]LLMModelInfo, error)) *MockLLMClient_AvailableModels_Call {
	_c.Call.Return(run)
	return _c
}

// Chat provides a mock function for the type MockLLMClient
func (_mock *MockLLMClient) Chat(ctx context.Context, req LLMChatRequest) (LLMChatResponse, error) {
	ret := _mock.Called(ctx, req)

	if len(ret) == 0 {
		panic("no return value specified for Chat")
	}

	var r0 LLMChatResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, LLMChatRequest) (LLMChatResponse, error)); ok {
		return returnFunc(ctx, req)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, LLMChatRequest) LLMChatResponse); ok {
		r0 = returnFunc(ctx, req)
	} else {
		r0 = ret.Get(0).(LLMChatResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, LLMChatRequest) error); ok {
		r1 = returnFunc(ctx, req)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLLMClient_Chat_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Chat'
type MockLLMClient_Chat_Call struct {
	*mock.Call
}

// Chat is a helper method to define mock.On call
//   - ctx context.Context
//   - req LLMChatRequest
func (_e *MockLLMClient_Expecter) Chat(ctx interface{}, req interface{}) *MockLLMClient_Chat_Call {
	return &MockLLMClient_Chat_Call{Call: _e.mock.On("Chat", ctx, req)}
}

func (_c *MockLLMClient_Chat_Call) Run(run func(ctx context.Context, req LLMChatRequest)) *MockLLMClient_Chat_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 LLMChatRequest
		if args[1] != nil {
			arg1 = args[1].(LLMChatRequest)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockLLMClient_Chat_Call) Return(lLMChatResponse LLMChatResponse, err error) *MockLLMClient_Chat_Call {
	_c.Call.Return(lLMChatResponse, err)
	return _c
}

func (_c *MockLLMClient_Chat_Call) RunAndReturn(run func(ctx context.Context, req LLMChatRequest) (LLMChatResponse, error)) *MockLLMClient_Chat_Call {
	_c.Call.Return(run)
	return _c
}

// ChatStream provides a mock function for the type MockLLMClient
func (_mock *MockLLMClient) ChatStream(ctx context.Context, req LLMChatRequest, onEvent LLMStreamEventCallback) error {
	ret := _mock.Called(ctx, req, onEvent)

	if len(ret) == 0 {
		panic("no return value specified for ChatStream")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, LLMChatRequest, LLMStreamEventCallback) error); ok {
		r0 = returnFunc(ctx, req, onEvent)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockLLMClient_ChatStream_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ChatStream'
type MockLLMClient_ChatStream_Call struct {
	*mock.Call
}

// ChatStream is a helper method to define mock.On call
//   - ctx context.Context
//   - req LLMChatRequest
//   - onEvent LLMStreamEventCallback
func (_e *MockLLMClient_Expecter) ChatStream(ctx interface{}, req interface{}, onEvent interface{}) *MockLLMClient_ChatStream_Call {
	return &MockLLMClient_ChatStream_Call{Call: _e.mock.On("ChatStream", ctx, req, onEvent)}
}

func (_c *MockLLMClient_ChatStream_Call) Run(run func(ctx context.Context, req LLMChatRequest, onEvent LLMStreamEventCallback)) *MockLLMClient_ChatStream_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 LLMChatRequest
		if args[1] != nil {
			arg1 = args[1].(LLMChatRequest)
		}
		var arg2 LLMStreamEventCallback
		if args[2] != nil {
			arg2 = args[2].(LLMStreamEventCallback)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLLMClient_ChatStream_Call) Return(err error) *MockLLMClient_ChatStream_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockLLMClient_ChatStream_Call) RunAndReturn(run func(ctx context.Context, req LLMChatRequest, onEvent LLMStreamEventCallback) error) *MockLLMClient_ChatStream_Call {
	_c.Call.Return(run)
	return _c
}

// Embed provides a mock function for the type MockLLMClient
func (_mock *MockLLMClient) Embed(ctx context.Context, model string, input string) (EmbedResponse, error) {
	ret := _mock.Called(ctx, model, input)

	if len(ret) == 0 {
		panic("no return value specified for Embed")
	}

	var r0 EmbedResponse
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) (EmbedResponse, error)); ok {
		return returnFunc(ctx, model, input)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, string, string) EmbedResponse); ok {
		r0 = returnFunc(ctx, model, input)
	} else {
		r0 = ret.Get(0).(EmbedResponse)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = returnFunc(ctx, model, input)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockLLMClient_Embed_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Embed'
type MockLLMClient_Embed_Call struct {
	*mock.Call
}

// Embed is a helper method to define mock.On call
//   - ctx context.Context
//   - model string
//   - input string
func (_e *MockLLMClient_Expecter) Embed(ctx interface{}, model interface{}, input interface{}) *MockLLMClient_Embed_Call {
	return &MockLLMClient_Embed_Call{Call: _e.mock.On("Embed", ctx, model, input)}
}

func (_c *MockLLMClient_Embed_Call) Run(run func(ctx context.Context, model string, input string)) *MockLLMClient_Embed_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 string
		if args[1] != nil {
			arg1 = args[1].(string)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
		)
	})
	return _c
}

func (_c *MockLLMClient_Embed_Call) Return(embedResponse EmbedResponse, err error) *MockLLMClient_Embed_Call {
	_c.Call.Return(embedResponse, err)
	return _c
}

func (_c *MockLLMClient_Embed_Call) RunAndReturn(run func(ctx context.Context, model string, input string) (EmbedResponse, error)) *MockLLMClient_Embed_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockOutboxRepository creates a new instance of MockOutboxRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockOutboxRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockOutboxRepository {
	mock := &MockOutboxRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockOutboxRepository is an autogenerated mock type for the OutboxRepository type
type MockOutboxRepository struct {
	mock.Mock
}

type MockOutboxRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockOutboxRepository) EXPECT() *MockOutboxRepository_Expecter {
	return &MockOutboxRepository_Expecter{mock: &_m.Mock}
}

// CreateEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) CreateEvent(ctx context.Context, event TodoEvent) error {
	ret := _mock.Called(ctx, event)

	if len(ret) == 0 {
		panic("no return value specified for CreateEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, TodoEvent) error); ok {
		r0 = returnFunc(ctx, event)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_CreateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateEvent'
type MockOutboxRepository_CreateEvent_Call struct {
	*mock.Call
}

// CreateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - event TodoEvent
func (_e *MockOutboxRepository_Expecter) CreateEvent(ctx interface{}, event interface{}) *MockOutboxRepository_CreateEvent_Call {
	return &MockOutboxRepository_CreateEvent_Call{Call: _e.mock.On("CreateEvent", ctx, event)}
}

func (_c *MockOutboxRepository_CreateEvent_Call) Run(run func(ctx context.Context, event TodoEvent)) *MockOutboxRepository_CreateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 TodoEvent
		if args[1] != nil {
			arg1 = args[1].(TodoEvent)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_CreateEvent_Call) Return(err error) *MockOutboxRepository_CreateEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_CreateEvent_Call) RunAndReturn(run func(ctx context.Context, event TodoEvent) error) *MockOutboxRepository_CreateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) DeleteEvent(ctx context.Context, eventID uuid.UUID) error {
	ret := _mock.Called(ctx, eventID)

	if len(ret) == 0 {
		panic("no return value specified for DeleteEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, eventID)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_DeleteEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteEvent'
type MockOutboxRepository_DeleteEvent_Call struct {
	*mock.Call
}

// DeleteEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID uuid.UUID
func (_e *MockOutboxRepository_Expecter) DeleteEvent(ctx interface{}, eventID interface{}) *MockOutboxRepository_DeleteEvent_Call {
	return &MockOutboxRepository_DeleteEvent_Call{Call: _e.mock.On("DeleteEvent", ctx, eventID)}
}

func (_c *MockOutboxRepository_DeleteEvent_Call) Run(run func(ctx context.Context, eventID uuid.UUID)) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_DeleteEvent_Call) Return(err error) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_DeleteEvent_Call) RunAndReturn(run func(ctx context.Context, eventID uuid.UUID) error) *MockOutboxRepository_DeleteEvent_Call {
	_c.Call.Return(run)
	return _c
}

// FetchPendingEvents provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) FetchPendingEvents(ctx context.Context, limit int) ([]OutboxEvent, error) {
	ret := _mock.Called(ctx, limit)

	if len(ret) == 0 {
		panic("no return value specified for FetchPendingEvents")
	}

	var r0 []OutboxEvent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) ([]OutboxEvent, error)); ok {
		return returnFunc(ctx, limit)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int) []OutboxEvent); ok {
		r0 = returnFunc(ctx, limit)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]OutboxEvent)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int) error); ok {
		r1 = returnFunc(ctx, limit)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockOutboxRepository_FetchPendingEvents_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'FetchPendingEvents'
type MockOutboxRepository_FetchPendingEvents_Call struct {
	*mock.Call
}

// FetchPendingEvents is a helper method to define mock.On call
//   - ctx context.Context
//   - limit int
func (_e *MockOutboxRepository_Expecter) FetchPendingEvents(ctx interface{}, limit interface{}) *MockOutboxRepository_FetchPendingEvents_Call {
	return &MockOutboxRepository_FetchPendingEvents_Call{Call: _e.mock.On("FetchPendingEvents", ctx, limit)}
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) Run(run func(ctx context.Context, limit int)) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) Return(outboxEvents []OutboxEvent, err error) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Return(outboxEvents, err)
	return _c
}

func (_c *MockOutboxRepository_FetchPendingEvents_Call) RunAndReturn(run func(ctx context.Context, limit int) ([]OutboxEvent, error)) *MockOutboxRepository_FetchPendingEvents_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateEvent provides a mock function for the type MockOutboxRepository
func (_mock *MockOutboxRepository) UpdateEvent(ctx context.Context, eventID uuid.UUID, status string, retryCount int, lastError string) error {
	ret := _mock.Called(ctx, eventID, status, retryCount, lastError)

	if len(ret) == 0 {
		panic("no return value specified for UpdateEvent")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID, string, int, string) error); ok {
		r0 = returnFunc(ctx, eventID, status, retryCount, lastError)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockOutboxRepository_UpdateEvent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateEvent'
type MockOutboxRepository_UpdateEvent_Call struct {
	*mock.Call
}

// UpdateEvent is a helper method to define mock.On call
//   - ctx context.Context
//   - eventID uuid.UUID
//   - status string
//   - retryCount int
//   - lastError string
func (_e *MockOutboxRepository_Expecter) UpdateEvent(ctx interface{}, eventID interface{}, status interface{}, retryCount interface{}, lastError interface{}) *MockOutboxRepository_UpdateEvent_Call {
	return &MockOutboxRepository_UpdateEvent_Call{Call: _e.mock.On("UpdateEvent", ctx, eventID, status, retryCount, lastError)}
}

func (_c *MockOutboxRepository_UpdateEvent_Call) Run(run func(ctx context.Context, eventID uuid.UUID, status string, retryCount int, lastError string)) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		var arg2 string
		if args[2] != nil {
			arg2 = args[2].(string)
		}
		var arg3 int
		if args[3] != nil {
			arg3 = args[3].(int)
		}
		var arg4 string
		if args[4] != nil {
			arg4 = args[4].(string)
		}
		run(
			arg0,
			arg1,
			arg2,
			arg3,
			arg4,
		)
	})
	return _c
}

func (_c *MockOutboxRepository_UpdateEvent_Call) Return(err error) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockOutboxRepository_UpdateEvent_Call) RunAndReturn(run func(ctx context.Context, eventID uuid.UUID, status string, retryCount int, lastError string) error) *MockOutboxRepository_UpdateEvent_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockBoardSummaryRepository creates a new instance of MockBoardSummaryRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockBoardSummaryRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockBoardSummaryRepository {
	mock := &MockBoardSummaryRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockBoardSummaryRepository is an autogenerated mock type for the BoardSummaryRepository type
type MockBoardSummaryRepository struct {
	mock.Mock
}

type MockBoardSummaryRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockBoardSummaryRepository) EXPECT() *MockBoardSummaryRepository_Expecter {
	return &MockBoardSummaryRepository_Expecter{mock: &_m.Mock}
}

// CalculateSummaryContent provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) CalculateSummaryContent(ctx context.Context) (BoardSummaryContent, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for CalculateSummaryContent")
	}

	var r0 BoardSummaryContent
	var r1 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (BoardSummaryContent, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) BoardSummaryContent); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(BoardSummaryContent)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) error); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Error(1)
	}
	return r0, r1
}

// MockBoardSummaryRepository_CalculateSummaryContent_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CalculateSummaryContent'
type MockBoardSummaryRepository_CalculateSummaryContent_Call struct {
	*mock.Call
}

// CalculateSummaryContent is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBoardSummaryRepository_Expecter) CalculateSummaryContent(ctx interface{}) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	return &MockBoardSummaryRepository_CalculateSummaryContent_Call{Call: _e.mock.On("CalculateSummaryContent", ctx)}
}

func (_c *MockBoardSummaryRepository_CalculateSummaryContent_Call) Run(run func(ctx context.Context)) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_CalculateSummaryContent_Call) Return(boardSummaryContent BoardSummaryContent, err error) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	_c.Call.Return(boardSummaryContent, err)
	return _c
}

func (_c *MockBoardSummaryRepository_CalculateSummaryContent_Call) RunAndReturn(run func(ctx context.Context) (BoardSummaryContent, error)) *MockBoardSummaryRepository_CalculateSummaryContent_Call {
	_c.Call.Return(run)
	return _c
}

// GetLatestSummary provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) GetLatestSummary(ctx context.Context) (BoardSummary, bool, error) {
	ret := _mock.Called(ctx)

	if len(ret) == 0 {
		panic("no return value specified for GetLatestSummary")
	}

	var r0 BoardSummary
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context) (BoardSummary, bool, error)); ok {
		return returnFunc(ctx)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context) BoardSummary); ok {
		r0 = returnFunc(ctx)
	} else {
		r0 = ret.Get(0).(BoardSummary)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context) bool); ok {
		r1 = returnFunc(ctx)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context) error); ok {
		r2 = returnFunc(ctx)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockBoardSummaryRepository_GetLatestSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetLatestSummary'
type MockBoardSummaryRepository_GetLatestSummary_Call struct {
	*mock.Call
}

// GetLatestSummary is a helper method to define mock.On call
//   - ctx context.Context
func (_e *MockBoardSummaryRepository_Expecter) GetLatestSummary(ctx interface{}) *MockBoardSummaryRepository_GetLatestSummary_Call {
	return &MockBoardSummaryRepository_GetLatestSummary_Call{Call: _e.mock.On("GetLatestSummary", ctx)}
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) Run(run func(ctx context.Context)) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		run(
			arg0,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) Return(boardSummary BoardSummary, b bool, err error) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Return(boardSummary, b, err)
	return _c
}

func (_c *MockBoardSummaryRepository_GetLatestSummary_Call) RunAndReturn(run func(ctx context.Context) (BoardSummary, bool, error)) *MockBoardSummaryRepository_GetLatestSummary_Call {
	_c.Call.Return(run)
	return _c
}

// StoreSummary provides a mock function for the type MockBoardSummaryRepository
func (_mock *MockBoardSummaryRepository) StoreSummary(ctx context.Context, summary BoardSummary) error {
	ret := _mock.Called(ctx, summary)

	if len(ret) == 0 {
		panic("no return value specified for StoreSummary")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, BoardSummary) error); ok {
		r0 = returnFunc(ctx, summary)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockBoardSummaryRepository_StoreSummary_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StoreSummary'
type MockBoardSummaryRepository_StoreSummary_Call struct {
	*mock.Call
}

// StoreSummary is a helper method to define mock.On call
//   - ctx context.Context
//   - summary BoardSummary
func (_e *MockBoardSummaryRepository_Expecter) StoreSummary(ctx interface{}, summary interface{}) *MockBoardSummaryRepository_StoreSummary_Call {
	return &MockBoardSummaryRepository_StoreSummary_Call{Call: _e.mock.On("StoreSummary", ctx, summary)}
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) Run(run func(ctx context.Context, summary BoardSummary)) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 BoardSummary
		if args[1] != nil {
			arg1 = args[1].(BoardSummary)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) Return(err error) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockBoardSummaryRepository_StoreSummary_Call) RunAndReturn(run func(ctx context.Context, summary BoardSummary) error) *MockBoardSummaryRepository_StoreSummary_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockCurrentTimeProvider creates a new instance of MockCurrentTimeProvider. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockCurrentTimeProvider(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockCurrentTimeProvider {
	mock := &MockCurrentTimeProvider{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockCurrentTimeProvider is an autogenerated mock type for the CurrentTimeProvider type
type MockCurrentTimeProvider struct {
	mock.Mock
}

type MockCurrentTimeProvider_Expecter struct {
	mock *mock.Mock
}

func (_m *MockCurrentTimeProvider) EXPECT() *MockCurrentTimeProvider_Expecter {
	return &MockCurrentTimeProvider_Expecter{mock: &_m.Mock}
}

// Now provides a mock function for the type MockCurrentTimeProvider
func (_mock *MockCurrentTimeProvider) Now() time.Time {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Now")
	}

	var r0 time.Time
	if returnFunc, ok := ret.Get(0).(func() time.Time); ok {
		r0 = returnFunc()
	} else {
		r0 = ret.Get(0).(time.Time)
	}
	return r0
}

// MockCurrentTimeProvider_Now_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Now'
type MockCurrentTimeProvider_Now_Call struct {
	*mock.Call
}

// Now is a helper method to define mock.On call
func (_e *MockCurrentTimeProvider_Expecter) Now() *MockCurrentTimeProvider_Now_Call {
	return &MockCurrentTimeProvider_Now_Call{Call: _e.mock.On("Now")}
}

func (_c *MockCurrentTimeProvider_Now_Call) Run(run func()) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockCurrentTimeProvider_Now_Call) Return(time1 time.Time) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Return(time1)
	return _c
}

func (_c *MockCurrentTimeProvider_Now_Call) RunAndReturn(run func() time.Time) *MockCurrentTimeProvider_Now_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockTodoRepository creates a new instance of MockTodoRepository. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockTodoRepository(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockTodoRepository {
	mock := &MockTodoRepository{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockTodoRepository is an autogenerated mock type for the TodoRepository type
type MockTodoRepository struct {
	mock.Mock
}

type MockTodoRepository_Expecter struct {
	mock *mock.Mock
}

func (_m *MockTodoRepository) EXPECT() *MockTodoRepository_Expecter {
	return &MockTodoRepository_Expecter{mock: &_m.Mock}
}

// CreateTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) CreateTodo(ctx context.Context, todo Todo) error {
	ret := _mock.Called(ctx, todo)

	if len(ret) == 0 {
		panic("no return value specified for CreateTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Todo) error); ok {
		r0 = returnFunc(ctx, todo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_CreateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTodo'
type MockTodoRepository_CreateTodo_Call struct {
	*mock.Call
}

// CreateTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - todo Todo
func (_e *MockTodoRepository_Expecter) CreateTodo(ctx interface{}, todo interface{}) *MockTodoRepository_CreateTodo_Call {
	return &MockTodoRepository_CreateTodo_Call{Call: _e.mock.On("CreateTodo", ctx, todo)}
}

func (_c *MockTodoRepository_CreateTodo_Call) Run(run func(ctx context.Context, todo Todo)) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Todo
		if args[1] != nil {
			arg1 = args[1].(Todo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_CreateTodo_Call) Return(err error) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_CreateTodo_Call) RunAndReturn(run func(ctx context.Context, todo Todo) error) *MockTodoRepository_CreateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) DeleteTodo(ctx context.Context, id uuid.UUID) error {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) error); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_DeleteTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTodo'
type MockTodoRepository_DeleteTodo_Call struct {
	*mock.Call
}

// DeleteTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockTodoRepository_Expecter) DeleteTodo(ctx interface{}, id interface{}) *MockTodoRepository_DeleteTodo_Call {
	return &MockTodoRepository_DeleteTodo_Call{Call: _e.mock.On("DeleteTodo", ctx, id)}
}

func (_c *MockTodoRepository_DeleteTodo_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_DeleteTodo_Call) Return(err error) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_DeleteTodo_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) error) *MockTodoRepository_DeleteTodo_Call {
	_c.Call.Return(run)
	return _c
}

// GetTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) GetTodo(ctx context.Context, id uuid.UUID) (Todo, bool, error) {
	ret := _mock.Called(ctx, id)

	if len(ret) == 0 {
		panic("no return value specified for GetTodo")
	}

	var r0 Todo
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) (Todo, bool, error)); ok {
		return returnFunc(ctx, id)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, uuid.UUID) Todo); ok {
		r0 = returnFunc(ctx, id)
	} else {
		r0 = ret.Get(0).(Todo)
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, uuid.UUID) bool); ok {
		r1 = returnFunc(ctx, id)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, uuid.UUID) error); ok {
		r2 = returnFunc(ctx, id)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTodoRepository_GetTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetTodo'
type MockTodoRepository_GetTodo_Call struct {
	*mock.Call
}

// GetTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - id uuid.UUID
func (_e *MockTodoRepository_Expecter) GetTodo(ctx interface{}, id interface{}) *MockTodoRepository_GetTodo_Call {
	return &MockTodoRepository_GetTodo_Call{Call: _e.mock.On("GetTodo", ctx, id)}
}

func (_c *MockTodoRepository_GetTodo_Call) Run(run func(ctx context.Context, id uuid.UUID)) *MockTodoRepository_GetTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 uuid.UUID
		if args[1] != nil {
			arg1 = args[1].(uuid.UUID)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_GetTodo_Call) Return(todo Todo, b bool, err error) *MockTodoRepository_GetTodo_Call {
	_c.Call.Return(todo, b, err)
	return _c
}

func (_c *MockTodoRepository_GetTodo_Call) RunAndReturn(run func(ctx context.Context, id uuid.UUID) (Todo, bool, error)) *MockTodoRepository_GetTodo_Call {
	_c.Call.Return(run)
	return _c
}

// ListTodos provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) ListTodos(ctx context.Context, page int, pageSize int, opts ...ListTodoOptions) ([]Todo, bool, error) {
	var tmpRet mock.Arguments
	if len(opts) > 0 {
		tmpRet = _mock.Called(ctx, page, pageSize, opts)
	} else {
		tmpRet = _mock.Called(ctx, page, pageSize)
	}
	ret := tmpRet

	if len(ret) == 0 {
		panic("no return value specified for ListTodos")
	}

	var r0 []Todo
	var r1 bool
	var r2 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...ListTodoOptions) ([]Todo, bool, error)); ok {
		return returnFunc(ctx, page, pageSize, opts...)
	}
	if returnFunc, ok := ret.Get(0).(func(context.Context, int, int, ...ListTodoOptions) []Todo); ok {
		r0 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]Todo)
		}
	}
	if returnFunc, ok := ret.Get(1).(func(context.Context, int, int, ...ListTodoOptions) bool); ok {
		r1 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		r1 = ret.Get(1).(bool)
	}
	if returnFunc, ok := ret.Get(2).(func(context.Context, int, int, ...ListTodoOptions) error); ok {
		r2 = returnFunc(ctx, page, pageSize, opts...)
	} else {
		r2 = ret.Error(2)
	}
	return r0, r1, r2
}

// MockTodoRepository_ListTodos_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListTodos'
type MockTodoRepository_ListTodos_Call struct {
	*mock.Call
}

// ListTodos is a helper method to define mock.On call
//   - ctx context.Context
//   - page int
//   - pageSize int
//   - opts ...ListTodoOptions
func (_e *MockTodoRepository_Expecter) ListTodos(ctx interface{}, page interface{}, pageSize interface{}, opts ...interface{}) *MockTodoRepository_ListTodos_Call {
	return &MockTodoRepository_ListTodos_Call{Call: _e.mock.On("ListTodos",
		append([]interface{}{ctx, page, pageSize}, opts...)...)}
}

func (_c *MockTodoRepository_ListTodos_Call) Run(run func(ctx context.Context, page int, pageSize int, opts ...ListTodoOptions)) *MockTodoRepository_ListTodos_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 int
		if args[1] != nil {
			arg1 = args[1].(int)
		}
		var arg2 int
		if args[2] != nil {
			arg2 = args[2].(int)
		}
		var arg3 []ListTodoOptions
		var variadicArgs []ListTodoOptions
		if len(args) > 3 {
			variadicArgs = args[3].([]ListTodoOptions)
		}
		arg3 = variadicArgs
		run(
			arg0,
			arg1,
			arg2,
			arg3...,
		)
	})
	return _c
}

func (_c *MockTodoRepository_ListTodos_Call) Return(todos []Todo, b bool, err error) *MockTodoRepository_ListTodos_Call {
	_c.Call.Return(todos, b, err)
	return _c
}

func (_c *MockTodoRepository_ListTodos_Call) RunAndReturn(run func(ctx context.Context, page int, pageSize int, opts ...ListTodoOptions) ([]Todo, bool, error)) *MockTodoRepository_ListTodos_Call {
	_c.Call.Return(run)
	return _c
}

// UpdateTodo provides a mock function for the type MockTodoRepository
func (_mock *MockTodoRepository) UpdateTodo(ctx context.Context, todo Todo) error {
	ret := _mock.Called(ctx, todo)

	if len(ret) == 0 {
		panic("no return value specified for UpdateTodo")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, Todo) error); ok {
		r0 = returnFunc(ctx, todo)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockTodoRepository_UpdateTodo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'UpdateTodo'
type MockTodoRepository_UpdateTodo_Call struct {
	*mock.Call
}

// UpdateTodo is a helper method to define mock.On call
//   - ctx context.Context
//   - todo Todo
func (_e *MockTodoRepository_Expecter) UpdateTodo(ctx interface{}, todo interface{}) *MockTodoRepository_UpdateTodo_Call {
	return &MockTodoRepository_UpdateTodo_Call{Call: _e.mock.On("UpdateTodo", ctx, todo)}
}

func (_c *MockTodoRepository_UpdateTodo_Call) Run(run func(ctx context.Context, todo Todo)) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 Todo
		if args[1] != nil {
			arg1 = args[1].(Todo)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockTodoRepository_UpdateTodo_Call) Return(err error) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockTodoRepository_UpdateTodo_Call) RunAndReturn(run func(ctx context.Context, todo Todo) error) *MockTodoRepository_UpdateTodo_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockUnitOfWork creates a new instance of MockUnitOfWork. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockUnitOfWork(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockUnitOfWork {
	mock := &MockUnitOfWork{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}

// MockUnitOfWork is an autogenerated mock type for the UnitOfWork type
type MockUnitOfWork struct {
	mock.Mock
}

type MockUnitOfWork_Expecter struct {
	mock *mock.Mock
}

func (_m *MockUnitOfWork) EXPECT() *MockUnitOfWork_Expecter {
	return &MockUnitOfWork_Expecter{mock: &_m.Mock}
}

// Execute provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Execute(ctx context.Context, fn func(uow UnitOfWork) error) error {
	ret := _mock.Called(ctx, fn)

	if len(ret) == 0 {
		panic("no return value specified for Execute")
	}

	var r0 error
	if returnFunc, ok := ret.Get(0).(func(context.Context, func(uow UnitOfWork) error) error); ok {
		r0 = returnFunc(ctx, fn)
	} else {
		r0 = ret.Error(0)
	}
	return r0
}

// MockUnitOfWork_Execute_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Execute'
type MockUnitOfWork_Execute_Call struct {
	*mock.Call
}

// Execute is a helper method to define mock.On call
//   - ctx context.Context
//   - fn func(uow UnitOfWork) error
func (_e *MockUnitOfWork_Expecter) Execute(ctx interface{}, fn interface{}) *MockUnitOfWork_Execute_Call {
	return &MockUnitOfWork_Execute_Call{Call: _e.mock.On("Execute", ctx, fn)}
}

func (_c *MockUnitOfWork_Execute_Call) Run(run func(ctx context.Context, fn func(uow UnitOfWork) error)) *MockUnitOfWork_Execute_Call {
	_c.Call.Run(func(args mock.Arguments) {
		var arg0 context.Context
		if args[0] != nil {
			arg0 = args[0].(context.Context)
		}
		var arg1 func(uow UnitOfWork) error
		if args[1] != nil {
			arg1 = args[1].(func(uow UnitOfWork) error)
		}
		run(
			arg0,
			arg1,
		)
	})
	return _c
}

func (_c *MockUnitOfWork_Execute_Call) Return(err error) *MockUnitOfWork_Execute_Call {
	_c.Call.Return(err)
	return _c
}

func (_c *MockUnitOfWork_Execute_Call) RunAndReturn(run func(ctx context.Context, fn func(uow UnitOfWork) error) error) *MockUnitOfWork_Execute_Call {
	_c.Call.Return(run)
	return _c
}

// Outbox provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Outbox() OutboxRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Outbox")
	}

	var r0 OutboxRepository
	if returnFunc, ok := ret.Get(0).(func() OutboxRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(OutboxRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Outbox_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Outbox'
type MockUnitOfWork_Outbox_Call struct {
	*mock.Call
}

// Outbox is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Outbox() *MockUnitOfWork_Outbox_Call {
	return &MockUnitOfWork_Outbox_Call{Call: _e.mock.On("Outbox")}
}

func (_c *MockUnitOfWork_Outbox_Call) Run(run func()) *MockUnitOfWork_Outbox_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Outbox_Call) Return(outboxRepository OutboxRepository) *MockUnitOfWork_Outbox_Call {
	_c.Call.Return(outboxRepository)
	return _c
}

func (_c *MockUnitOfWork_Outbox_Call) RunAndReturn(run func() OutboxRepository) *MockUnitOfWork_Outbox_Call {
	_c.Call.Return(run)
	return _c
}

// Todo provides a mock function for the type MockUnitOfWork
func (_mock *MockUnitOfWork) Todo() TodoRepository {
	ret := _mock.Called()

	if len(ret) == 0 {
		panic("no return value specified for Todo")
	}

	var r0 TodoRepository
	if returnFunc, ok := ret.Get(0).(func() TodoRepository); ok {
		r0 = returnFunc()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(TodoRepository)
		}
	}
	return r0
}

// MockUnitOfWork_Todo_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Todo'
type MockUnitOfWork_Todo_Call struct {
	*mock.Call
}

// Todo is a helper method to define mock.On call
func (_e *MockUnitOfWork_Expecter) Todo() *MockUnitOfWork_Todo_Call {
	return &MockUnitOfWork_Todo_Call{Call: _e.mock.On("Todo")}
}

func (_c *MockUnitOfWork_Todo_Call) Run(run func()) *MockUnitOfWork_Todo_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockUnitOfWork_Todo_Call) Return(todoRepository TodoRepository) *MockUnitOfWork_Todo_Call {
	_c.Call.Return(todoRepository)
	return _c
}

func (_c *MockUnitOfWork_Todo_Call) RunAndReturn(run func() TodoRepository) *MockUnitOfWork_Todo_Call {
	_c.Call.Return(run)
	return _c
}
